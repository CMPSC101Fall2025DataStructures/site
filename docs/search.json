[
  {
    "objectID": "lessons/gettingToKnowYou.html#introduce-your-partner",
    "href": "lessons/gettingToKnowYou.html#introduce-your-partner",
    "title": "Activity: Getting To Know You",
    "section": "Introduce Your Partner!",
    "text": "Introduce Your Partner!\nChoose the person sitting right next to you. Have a conversation with the person to find out who they are. Ask them about;\n\nHow they would like to be called in class,\nWhere they are from,\nWhat types of classes they like,\nWhat they enjoy doing on campus,\nWhat is their favorite music\nWhy they are in this course at Allegheny College. Take turns sharing.\n\nThen, each of you will present the other to the course today."
  },
  {
    "objectID": "lessons/gettingToKnowYou.html#survey",
    "href": "lessons/gettingToKnowYou.html#survey",
    "title": "Activity: Getting To Know You",
    "section": "Survey",
    "text": "Survey\nI would like to get to know you a bit better! Please fill out this short survey so I can learn more about you and your interests. Note: one of the questions will ask you for your Dicord handle. If you have not yet got a Discord account, please go to https://discord.com/ to get started. For our course, please use your actual name in Discord.\nSurvey Link: https://forms.gle/oM5mxSCZ2Umfhrqp7"
  },
  {
    "objectID": "lessons/stringCheese.html",
    "href": "lessons/stringCheese.html",
    "title": "Just For Fun: String Cheese Demo",
    "section": "",
    "text": "Lesson Objectives\n\n\n\nBy the end of this lesson, you will be able to:\n\nPrint strings in Python\nUse for loops with range()\nFormat strings with f-strings\nUnderstand string repetition"
  },
  {
    "objectID": "lessons/stringCheese.html#introduction",
    "href": "lessons/stringCheese.html#introduction",
    "title": "Just For Fun: String Cheese Demo",
    "section": "Introduction",
    "text": "Introduction\nIn this lesson, we‚Äôll learn how to print ‚ÄúString Cheese‚Äù using Python! This fun example will teach you about loops, strings, and formatting."
  },
  {
    "objectID": "lessons/stringCheese.html#key-concepts",
    "href": "lessons/stringCheese.html#key-concepts",
    "title": "Just For Fun: String Cheese Demo",
    "section": "Key Concepts",
    "text": "Key Concepts\n\n\nüí° Concept 1: String Printing and Loops\n\nWe can use Python‚Äôs print() function combined with for loops to create repeated output. The range() function helps us control how many times something repeats.\nExample:\n# Print String Cheese multiple times\nfor i in range(5):\n    print(f\"String Cheese : {i}\")"
  },
  {
    "objectID": "lessons/stringCheese.html#interactive-examples",
    "href": "lessons/stringCheese.html#interactive-examples",
    "title": "Just For Fun: String Cheese Demo",
    "section": "Interactive Examples",
    "text": "Interactive Examples\n\nExample 1: Basic String Cheese Loop\n\nWhat this code does: This creates a simple loop that prints ‚ÄúString Cheese‚Äù 10 times, each with a number.\n\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\n\n\n‚ñ∂ Run Code üóë Clear üìù Load Example üîç+ Larger Font üîç- Smaller Font\n\n\nExample 2: String Cheese with Custom Messages\n\nWhat this code does: This example shows how to create more creative String Cheese messages with different formatting.\n\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\n\n\n‚ñ∂ Run Code üóë Clear üìù Load Example\n\n\nTry It Yourself\n\nüöÄ Challenge: Create your own String Cheese variations!\nYour task: Write a loop that prints ‚ÄúString Cheese‚Äù with different numbers and messages.\nHint: Try using different ranges and string formatting options.\n\n\n\n\n\n\n\n\nReady for your solution!\n\n\n\n\n\n\n\n‚ñ∂ Run Code üóë Clear üí° Show Solution\n\n\nSummary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored:\n\nString printing with print() function\nFor loops with range() function\nF-string formatting for dynamic messages\nCreative text output and formatting\n\n\n\n\n\nNext Steps\n\n\n\n\n\n\nComing Up Next\n\n\n\nIn the next lesson, we‚Äôll cover: - Variables and data types - More complex string operations\n\n\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nPython String Formatting\nPython For Loops\nPractice Problems"
  },
  {
    "objectID": "lessons/stringCheese.html#try-it-yourself",
    "href": "lessons/stringCheese.html#try-it-yourself",
    "title": "Just For Fun: String Cheese Demo",
    "section": "Try It Yourself",
    "text": "Try It Yourself\n\nüöÄ Challenge: Create your own String Cheese variations!\nYour task: Write a loop that prints ‚ÄúString Cheese‚Äù with different numbers and messages.\nHint: Try using different ranges and string formatting options.\n\n\n\n\n\n\n\n\nReady for your solution!\n\n\n\n\n\n\n\n‚ñ∂ Run Code üóë Clear üí° Show Solution\n\n\nSummary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored:\n\nString printing with print() function\nFor loops with range() function\nF-string formatting for dynamic messages\nCreative text output and formatting\n\n\n\n\n\nNext Steps\n\n\n\n\n\n\nComing Up Next\n\n\n\nIn the next lesson, we‚Äôll cover: - Variables and data types - More complex string operations\n\n\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nPython String Formatting\nPython For Loops\nPractice Problems"
  },
  {
    "objectID": "lessons/stringCheese.html#summary",
    "href": "lessons/stringCheese.html#summary",
    "title": "Just For Fun: String Cheese Demo",
    "section": "Summary",
    "text": "Summary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored:\n\nString printing with print() function\nFor loops with range() function\nF-string formatting for dynamic messages\nCreative text output and formatting"
  },
  {
    "objectID": "lessons/stringCheese.html#next-steps",
    "href": "lessons/stringCheese.html#next-steps",
    "title": "Just For Fun: String Cheese Demo",
    "section": "Next Steps",
    "text": "Next Steps\n\n\n\n\n\n\nComing Up Next\n\n\n\nIn the next lesson, we‚Äôll cover: - Variables and data types - More complex string operations\n\n\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nPython String Formatting\nPython For Loops\nPractice Problems"
  },
  {
    "objectID": "firstWeek/fibonacci.html",
    "href": "firstWeek/fibonacci.html",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "",
    "text": "Lesson Objectives\n\n\n\nBy the end of this lesson, you will be able to:\n\nUnderstand the mathematical definition of the Fibonacci sequence\nImplement recursive Fibonacci calculation\nCreate an iterative Fibonacci algorithm\nApply Binet‚Äôs formula for direct Fibonacci computation"
  },
  {
    "objectID": "firstWeek/fibonacci.html#introduction",
    "href": "firstWeek/fibonacci.html#introduction",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Introduction",
    "text": "Introduction\nThe Fibonacci sequence is one of the most famous sequences in mathematics, appearing in nature, art, and computer science. Each number is the sum of the two preceding ones: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144‚Ä¶\nIn this lesson, we‚Äôll explore three different computational approaches to generate Fibonacci numbers, each with unique advantages and trade-offs."
  },
  {
    "objectID": "firstWeek/fibonacci.html#key-concepts",
    "href": "firstWeek/fibonacci.html#key-concepts",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Key Concepts",
    "text": "Key Concepts\n\n\nüí° Concept 1: Mathematical Definition\n\nThe Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n &gt; 1\nThis recursive definition leads naturally to our first implementation approach.\nExample:\n# Mathematical definition\n# F(5) = F(4) + F(3) = 5\n# F(4) = F(3) + F(2) = 3 \n# F(3) = F(2) + F(1) = 2\n\n\n\nüí° Concept 2: Computational Complexity\n\nDifferent algorithms have different time complexities: - Recursive: O(2^n) - exponential, very slow for large n - Iterative: O(n) - linear, efficient for reasonable n - Binet‚Äôs Formula: O(1) - constant time, but limited by floating-point precision\nExample:\n# Time comparison for F(40):\n# Recursive: ~1.6 billion operations\n# Iterative: ~40 operations  \n# Binet's: ~5 operations"
  },
  {
    "objectID": "firstWeek/fibonacci.html#interactive-examples",
    "href": "firstWeek/fibonacci.html#interactive-examples",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Interactive Examples",
    "text": "Interactive Examples\n\nExample 1: Recursive Fibonacci\n\nWhat this code does: This implements the mathematical definition directly using recursion. Each function call splits into two more calls, creating a tree-like computation structure. While elegant, it‚Äôs very inefficient for large numbers.\n\nExample Code:\ndef fibonacci_recursive(n):\n    \"\"\"Calculate Fibonacci number using recursion\"\"\"\n    if n &lt;= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\n\n# Test with small numbers (try 10, 15, 20)\nfor i in range(11):\n    print(f'F({i}) = {fibonacci_recursive(i)}')\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\ndef fibonacci_recursive(n):\n    \"\"\"Calculate Fibonacci number using recursion\"\"\"\n    if n &lt;= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\n\n# Test with small numbers (try 10, 15, 20)\nfor i in range(11):\n    print(f'F({i}) = {fibonacci_recursive(i)}')\n\n‚ñ∂ Run Code üóë Clear üîç+ Larger Font üîç- Smaller Font\n\n\nExample 2: Iterative Fibonacci\n\nWhat this code does: This approach builds up the sequence from the bottom, keeping track of only the last two numbers. It‚Äôs much more efficient than recursion, using O(n) time and O(1) space.\n\nExample Code:\ndef fibonacci_iterative(n):\n    \"\"\"Calculate Fibonacci number using iteration\"\"\"\n    if n &lt;= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Test with larger numbers (try 50, 100)\nfor i in [10, 20, 30, 40, 50]:\n    print(f'F({i}) = {fibonacci_iterative(i)}')\n\n# Show the sequence\nprint(\"\\nFirst 20 Fibonacci numbers:\")\nfib_sequence = [fibonacci_iterative(i) for i in range(20)]\nprint(fib_sequence)\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\ndef fibonacci_iterative(n):\n    \"\"\"Calculate Fibonacci number using iteration\"\"\"\n    if n &lt;= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Test with larger numbers (try 50, 100)\nfor i in [10, 20, 30, 40, 50]:\n    print(f'F({i}) = {fibonacci_iterative(i)}')\n\n# Show the sequence\nprint(\"\\nFirst 20 Fibonacci numbers:\")\nfib_sequence = [fibonacci_iterative(i) for i in range(20)]\nprint(fib_sequence)\n\n‚ñ∂ Run Code üóë Clear\n\n\nExample 3: Binet‚Äôs Formula\n\nWhat this code does: This uses Binet‚Äôs closed-form formula to calculate Fibonacci numbers directly using the golden ratio. It‚Äôs mathematically elegant and theoretically O(1), but limited by floating-point precision for very large numbers.\n\nExample Code:\nimport math\n\ndef fibonacci_binet(n):\n    \"\"\"Calculate Fibonacci number using Binet's formula\"\"\"\n    if n &lt;= 1:\n        return n\n    \n    # Golden ratio\n    phi = (1 + math.sqrt(5)) / 2\n    psi = (1 - math.sqrt(5)) / 2\n    \n    # Binet's formula\n    result = (phi**n - psi**n) / math.sqrt(5)\n    return round(result)\n\n# Test Binet's formula\nprint(\"Binet's Formula Results:\")\nfor i in range(15):\n    print(f'F({i}) = {fibonacci_binet(i)}')\n\n# Compare accuracy with iterative method\nprint(\"\\nAccuracy comparison (Binet vs Iterative):\")\nfor i in [20, 30, 40, 50]:\n    binet_result = fibonacci_binet(i)\n    iterative_result = fibonacci_iterative(i)\n    match = \"‚úì\" if binet_result == iterative_result else \"‚úó\"\n    print(f'F({i}): Binet={binet_result}, Iterative={iterative_result} {match}')\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\nimport math\n\ndef fibonacci_binet(n):\n    \"\"\"Calculate Fibonacci number using Binet's formula\"\"\"\n    if n &lt;= 1:\n        return n\n    \n    # Golden ratio\n    phi = (1 + math.sqrt(5)) / 2\n    psi = (1 - math.sqrt(5)) / 2\n    \n    # Binet's formula\n    result = (phi**n - psi**n) / math.sqrt(5)\n    return round(result)\n\n# Test Binet's formula\nprint(\"Binet's Formula Results:\")\nfor i in range(15):\n    print(f'F({i}) = {fibonacci_binet(i)}')\n\n# Compare accuracy with iterative method\nprint(\"\\nAccuracy comparison (Binet vs Iterative):\")\nfor i in [20, 30, 40, 50]:\n    binet_result = fibonacci_binet(i)\n    iterative_result = fibonacci_iterative(i)\n    match = \"‚úì\" if binet_result == iterative_result else \"‚úó\"\n    print(f'F({i}): Binet={binet_result}, Iterative={iterative_result} {match}')\n\n‚ñ∂ Run Code üóë Clear\n\n\nChallenge Yourself\n\nPerformance Comparison Challenge\nNow that you‚Äôve seen all three methods, let‚Äôs compare their performance! Try running this timing comparison to see the dramatic differences between approaches:\nChallenge Code:\nimport time\n\n# Time comparison for different methods\ndef time_function(func, n):\n    start = time.time()\n    result = func(n)\n    end = time.time()\n    return result, end - start\n\n# Test with a moderate number (careful with recursive!)\ntest_n = 30\nprint(f\"Computing F({test_n}) with different methods:\\n\")\n\n# Iterative (fast)\nresult, duration = time_function(fibonacci_iterative, test_n)\nprint(f\"Iterative: {result} (took {duration:.6f} seconds)\")\n\n# Binet's formula (very fast)\nresult, duration = time_function(fibonacci_binet, test_n)\nprint(f\"Binet's:   {result} (took {duration:.6f} seconds)\")\n\n# Recursive (slow - be patient!)\nprint(\"\\nRecursive method running... (this will take a while)\")\nresult, duration = time_function(fibonacci_recursive, test_n)\nprint(f\"Recursive: {result} (took {duration:.6f} seconds)\")\n\nprint(\"\\nüéØ Challenge: Try changing test_n to see how each method scales!\")\nprint(\"   - Iterative & Binet's can handle n=50+ easily\")\nprint(\"   - Recursive becomes very slow after n=35\")\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\nimport time\n\n# Time comparison for different methods\ndef time_function(func, n):\n    start = time.time()\n    result = func(n)\n    end = time.time()\n    return result, end - start\n\n# Test with a moderate number (careful with recursive!)\ntest_n = 30\n\nprint(f\"Computing F({test_n}) with different methods:\\n\")\n\n# Iterative (fast)\nresult, duration = time_function(fibonacci_iterative, test_n)\nprint(f\"Iterative: {result} (took {duration:.6f} seconds)\")\n\n# Binet's formula (very fast)\nresult, duration = time_function(fibonacci_binet, test_n)\nprint(f\"Binet's:   {result} (took {duration:.6f} seconds)\")\n\n# Recursive (slow - be patient!)\nprint(\"\\nRecursive method running... (this will take a while)\")\nresult, duration = time_function(fibonacci_recursive, test_n)\nprint(f\"Recursive: {result} (took {duration:.6f} seconds)\")\n\nprint(\"\\nüéØ Challenge: Try changing test_n to see how each method scales!\")\nprint(\"   - Iterative & Binet's can handle n=50+ easily\")\nprint(\"   - Recursive becomes very slow after n=35\")\n\n‚ñ∂ Run Code üóë Clear\n\n\nYour Turn!\n\nChallenge Tasks:\n\nModify the recursive function to use memoization (caching previous results) to make it faster\nCreate a function that generates the first n Fibonacci numbers using your preferred method\nInvestigate the golden ratio - calculate œÜ (phi) from consecutive Fibonacci numbers: F(n+1)/F(n)\nResearch question: Why does Binet‚Äôs formula eventually become inaccurate for very large numbers?\n\nUse any of the terminals above to experiment with these challenges!\n\n\n\nSummary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored three different approaches to computing Fibonacci numbers:\n\nRecursive Implementation: Elegant but exponentially slow (O(2^n)) - demonstrates the mathematical definition directly\nIterative Implementation: Efficient and practical (O(n) time, O(1) space) - builds solutions step-by-step\n\nBinet‚Äôs Formula: Mathematically beautiful (O(1) but limited by precision) - uses the golden ratio for direct calculation\nPerformance Analysis: Understanding how algorithm choice dramatically affects execution time\n\n\n\n\n\nKey Takeaways\nEach approach teaches us different programming and mathematical concepts: - Recursion and why it can be inefficient without optimization (memoization) - Iteration and the power of building solutions incrementally - Mathematical formulas and their computational trade-offs between elegance and precision - Algorithm complexity and how it affects real-world performance\nThe Fibonacci sequence appears everywhere in nature and mathematics, making it a perfect example for understanding both algorithmic thinking and mathematical beauty in programming!\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nFibonacci Numbers in Nature\nGolden Ratio and Mathematics\nAlgorithm Complexity Guide"
  },
  {
    "objectID": "firstWeek/fibonacci.html#challenge-yourself",
    "href": "firstWeek/fibonacci.html#challenge-yourself",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Challenge Yourself",
    "text": "Challenge Yourself\n\nPerformance Comparison Challenge\nNow that you‚Äôve seen all three methods, let‚Äôs compare their performance! Try running this timing comparison to see the dramatic differences between approaches:\nChallenge Code:\nimport time\n\n# Time comparison for different methods\ndef time_function(func, n):\n    start = time.time()\n    result = func(n)\n    end = time.time()\n    return result, end - start\n\n# Test with a moderate number (careful with recursive!)\ntest_n = 30\nprint(f\"Computing F({test_n}) with different methods:\\n\")\n\n# Iterative (fast)\nresult, duration = time_function(fibonacci_iterative, test_n)\nprint(f\"Iterative: {result} (took {duration:.6f} seconds)\")\n\n# Binet's formula (very fast)\nresult, duration = time_function(fibonacci_binet, test_n)\nprint(f\"Binet's:   {result} (took {duration:.6f} seconds)\")\n\n# Recursive (slow - be patient!)\nprint(\"\\nRecursive method running... (this will take a while)\")\nresult, duration = time_function(fibonacci_recursive, test_n)\nprint(f\"Recursive: {result} (took {duration:.6f} seconds)\")\n\nprint(\"\\nüéØ Challenge: Try changing test_n to see how each method scales!\")\nprint(\"   - Iterative & Binet's can handle n=50+ easily\")\nprint(\"   - Recursive becomes very slow after n=35\")\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\nimport time\n\n# Time comparison for different methods\ndef time_function(func, n):\n    start = time.time()\n    result = func(n)\n    end = time.time()\n    return result, end - start\n\n# Test with a moderate number (careful with recursive!)\ntest_n = 30\n\nprint(f\"Computing F({test_n}) with different methods:\\n\")\n\n# Iterative (fast)\nresult, duration = time_function(fibonacci_iterative, test_n)\nprint(f\"Iterative: {result} (took {duration:.6f} seconds)\")\n\n# Binet's formula (very fast)\nresult, duration = time_function(fibonacci_binet, test_n)\nprint(f\"Binet's:   {result} (took {duration:.6f} seconds)\")\n\n# Recursive (slow - be patient!)\nprint(\"\\nRecursive method running... (this will take a while)\")\nresult, duration = time_function(fibonacci_recursive, test_n)\nprint(f\"Recursive: {result} (took {duration:.6f} seconds)\")\n\nprint(\"\\nüéØ Challenge: Try changing test_n to see how each method scales!\")\nprint(\"   - Iterative & Binet's can handle n=50+ easily\")\nprint(\"   - Recursive becomes very slow after n=35\")\n\n‚ñ∂ Run Code üóë Clear\n\n\nYour Turn!\n\nChallenge Tasks:\n\nModify the recursive function to use memoization (caching previous results) to make it faster\nCreate a function that generates the first n Fibonacci numbers using your preferred method\nInvestigate the golden ratio - calculate œÜ (phi) from consecutive Fibonacci numbers: F(n+1)/F(n)\nResearch question: Why does Binet‚Äôs formula eventually become inaccurate for very large numbers?\n\nUse any of the terminals above to experiment with these challenges!\n\n\n\nSummary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored three different approaches to computing Fibonacci numbers:\n\nRecursive Implementation: Elegant but exponentially slow (O(2^n)) - demonstrates the mathematical definition directly\nIterative Implementation: Efficient and practical (O(n) time, O(1) space) - builds solutions step-by-step\n\nBinet‚Äôs Formula: Mathematically beautiful (O(1) but limited by precision) - uses the golden ratio for direct calculation\nPerformance Analysis: Understanding how algorithm choice dramatically affects execution time\n\n\n\n\n\nKey Takeaways\nEach approach teaches us different programming and mathematical concepts: - Recursion and why it can be inefficient without optimization (memoization) - Iteration and the power of building solutions incrementally - Mathematical formulas and their computational trade-offs between elegance and precision - Algorithm complexity and how it affects real-world performance\nThe Fibonacci sequence appears everywhere in nature and mathematics, making it a perfect example for understanding both algorithmic thinking and mathematical beauty in programming!\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nFibonacci Numbers in Nature\nGolden Ratio and Mathematics\nAlgorithm Complexity Guide"
  },
  {
    "objectID": "firstWeek/fibonacci.html#summary",
    "href": "firstWeek/fibonacci.html#summary",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Summary",
    "text": "Summary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored three different approaches to computing Fibonacci numbers:\n\nRecursive Implementation: Elegant but exponentially slow (O(2^n)) - demonstrates the mathematical definition directly\nIterative Implementation: Efficient and practical (O(n) time, O(1) space) - builds solutions step-by-step\n\nBinet‚Äôs Formula: Mathematically beautiful (O(1) but limited by precision) - uses the golden ratio for direct calculation\nPerformance Analysis: Understanding how algorithm choice dramatically affects execution time"
  },
  {
    "objectID": "firstWeek/fibonacci.html#key-takeaways",
    "href": "firstWeek/fibonacci.html#key-takeaways",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Key Takeaways",
    "text": "Key Takeaways\nEach approach teaches us different programming and mathematical concepts: - Recursion and why it can be inefficient without optimization (memoization) - Iteration and the power of building solutions incrementally - Mathematical formulas and their computational trade-offs between elegance and precision - Algorithm complexity and how it affects real-world performance\nThe Fibonacci sequence appears everywhere in nature and mathematics, making it a perfect example for understanding both algorithmic thinking and mathematical beauty in programming!\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nFibonacci Numbers in Nature\nGolden Ratio and Mathematics\nAlgorithm Complexity Guide"
  },
  {
    "objectID": "syllabus/syllabus.html",
    "href": "syllabus/syllabus.html",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "",
    "text": "Class Sessions: MWF 10:00 AM to 10:50 AM, Alden 101\nLaboratory Session: Thursday, 2:30 PM to 4 PM, Alden 101\nInstructor: Dr.¬†Bonham-Carter, obonhamcarter@allegheny.edu\nOffice Location: Alden Hall 203\nInstructor Office Hours: Visit the below URL to find availability and schedule and appointment. https://www.oliverbonhamcarter.com/contactandabout/\nBook An Appointment!: https://calendar.app.google/dEK6MftNGNLV1Ft96\nNote: If the office hours times are not convenient, then please reach out to me and we can find an alternative time to meet."
  },
  {
    "objectID": "syllabus/syllabus.html#quick-links",
    "href": "syllabus/syllabus.html#quick-links",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Quick Links",
    "text": "Quick Links\n\nThe attendance form\nToken Form for Automatic Extension"
  },
  {
    "objectID": "syllabus/syllabus.html#course-description",
    "href": "syllabus/syllabus.html#course-description",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Course Description",
    "text": "Course Description\nA continuation of CMPSC 100 with an emphasis on implementing, using, and evaluating the computational structures needed to efficiently store and retrieve digital data. Participating in hands-on activities that often require teamwork, students create data structures and algorithms whose correctness and performance they study through proofs and experimentation. Students continue to refine their ability to organize and document a program‚Äôs source code so that it effectively communicates with the intended users and maintainers. During a weekly laboratory session, students use state-of-the-art technology to complete projects, reporting on their results through both written documents and oral presentations.\nQuantitative Reasoning (QR): Quantitative Reasoning is the ability to understand, investigate, communicate, and contextualize numerical, symbolic, and graphical information towards the exploration of natural, physical, behavioral, or social phenomena.\nScientific Process and Knowledge (SP): Courses involving Scientific Process and Knowledge aim to convey an understanding of what is known or can be known about the natural world; apply scientific reasoning towards the analysis and synthesis of scientific information; and create scientifically literate citizens who can engage productively in problem solving.\n\nPrerequisite: CMPSC 100 or permission of the instructor.\nDistribution Requirements: QR, SP."
  },
  {
    "objectID": "syllabus/syllabus.html#course-learning-objectives",
    "href": "syllabus/syllabus.html#course-learning-objectives",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Course Learning Objectives",
    "text": "Course Learning Objectives\n\nWhen solving a problem with a Python program, accurately describe data structures and algorithms and their inherent trade-offs.\nUse data structures and algorithms to correctly and efficiently solve a problem through the use of a Python program.\nUse empirical methods to characterize the performance of a Python program that uses data structures and algorithms.\nUse industry-standard practices, such as testing and debugging, and professional-grade integrated development environments (IDEs), command-line tools, and version control systems to implement Python programs.\nImplement Python programs and documentation that conforms to industry-standard formats and styles.\n\nLearning Outcome QR: Students who successfully complete this requirement will demonstrate an understanding of how to interpret numeric data and/or their graphical or symbolic representations.\nLearning Outcome SP: Students who successfully complete this requirement will demonstrate an understanding of the nature, approaches, and domain of scientific inquiry."
  },
  {
    "objectID": "syllabus/syllabus.html#materials",
    "href": "syllabus/syllabus.html#materials",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Materials",
    "text": "Materials\n\nTextbook\nIntroduction to Computation and Programming Using Python by John V. Guttag\n\n\n\nOnline Resources and Course Materials\n\nW3schools  \nCourse GitHub Organization\nJupyter Notebooks Directory\nGuttag Textbook Publisher Preview\nGuttag Textbook Google Previews\nAdditional Guttag Textbook Availability\nGuttag Lectures\nPython Docs Proactive Programmers\n\n\n\nSelected Software and Technologies\nWe will be using the following technologies in class.\n\nVSCode\nPython 3.12 or later\npipx\nPoetry\nGatorgrade\nGit\nFree GitHub Account\nFree Discord Account\nAllegheny College Email\n\n\n\nGrading\n\n\nGradebook Repository\nGradeBook repository will be used to deliver your grades from your activities and labs to you. In this repository, you will find a file which contains the same information that the instructor has in the gradebook. While it is a repository that you will pull from, you will never need to push anything to this repository.\nPlease use the following URL to create your gradebook repository; https://classroom.github.com/a/34hXX52q.\n\nGrading Scale\n\n\n\n\n\n\n\n\n\n\n\n\nLetter\nRange\nLetter\nRange\nLetter\nRange\n\n\n\n\nA\n96 - 100\nA-\n90 - 95.9\n\n\n\n\nB+\n87 - 89.9\nB\n83 - 86.9\nB-\n80 - 82.9\n\n\nC+\n77 - 79.9\nC\n73 - 76.9\nC-\n70 - 72.9\n\n\nD+\n67 - 69.9\nD\n63 - 66.9\nF\n59.9 and below\n\n\n\n\n\nBenchmarks\nThe grade that a student receives in this class will be based on the following categories. All percentages are approximate and, if the need to do so presents itself, it is possible for the assigned percentages to change during the academic semester.\n\n\n\nCategory\nPercentage\nAssessment metric\n\n\n\n\nClass Participation and Activities\n20%\ncheck mark grade\n\n\nLabs\n40%\nletter grade\n\n\nMidterm Exam\n20%\nletter grade\n\n\nFinal Project\n20%\nletter grade\n\n\nTotal\n100%\n\n\n\n\n\n\nDefinitions of Grading Categories\n\nClass Participation: All students are required to actively participate during all of the class sessions. Your participation will take forms such as answering questions about the required reading assignments, completing in-class exercises, asking constructive questions of the other members of the class, giving presentations, leading a discussion session in class.% and in the course‚Äôs Slack channels.\nActivities: These assignments invite students to explore different techniques for rigorously designing, implementing, programming, evaluating, and documenting real-world Python programs. These assignments will invite students to use tools like a text editor, a terminal window, and a modern Python development environment to implement functions that strike the right balance between understandability, generalizability, and specialization. Students will also use the data collected from running experiments to evaluate the implementation of a Python function as they consider, for instance, its efficiency and correctness. Knowledge gained from the class and the textbook will be integral to the completion of these projects. Unless other information is given about a due date, activities are to be completed by the end of class.\nExams: The exams will cover all of the material in their associated module(s). The finalized date for each of the exams will be announced at least one week in advance of the scheduled date. Unless prior arrangements are made with the course instructor, all students will be expected to take these exams on the scheduled date and complete the exams in the stated period of time.\nFinal Project: This project will present you with an opportunity to design and implement a correct and carefully evaluated programming solution for a specific problem. Completion of the final project will require you to apply the knowledge, programming and technical skills that you have acquired during the course. The details for the final project will be given approximately a month before the project due date (during finals week)."
  },
  {
    "objectID": "syllabus/syllabus.html#schedule-at-a-glance",
    "href": "syllabus/syllabus.html#schedule-at-a-glance",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Schedule At-A-Glance",
    "text": "Schedule At-A-Glance\n\nWeek One: Software Operations (Guttag Chapter 1)\nWeek Two: Python Foundations (Guttage Chapter 2)\nWeek Three: Numerical Programs (Guttag Chapter 3)\nWeek Four: Function Scope (Guttag Chapter 4)\nWeek Five: Structured Types (Guttag Chapter 5)\nWeek Six: Mutability and Aliasing (Guttag Chapter 5)\nWeek Seven: Recursion (Guttag Chapter 6)\nFall Break (Thursday to Sunday)\nWeek Nine: Modules and Files (Guttag Chapter 7)\nWeek Ten: Testing and Handling Exceptions (Guttag Chapter 8 and 9)\nWeek Eleven: Object-Oriented Programming (Guttag Chapter 10)\nWeek Twelve: Algorithmic Complexity (Guttag Chapter 11)\nWeek Thirteen: Sorting (Guttag Chapter 12)\nWeek Fourteen: Data Structures (Guttag Chapter 12 cont)\nWeek Fifteen: Optimization Problems (Guttag Chapter 14)\nWeek Sixteen: Review\n\n\nFinal Deliverable\n\nWednesday, December 10, 2025 at 9:00 AM (Complete Final Exam Schedule)\nExam Code: G"
  },
  {
    "objectID": "syllabus/syllabus.html#assignment-policies",
    "href": "syllabus/syllabus.html#assignment-policies",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Assignment Policies",
    "text": "Assignment Policies\n\nAssignment Submission\nAll graded components of the course are expected to be turned in on time. Due dates are provided on each assignment. Electronic versions of the Engineering and Specification Labs must be submitted to through a student‚Äôs GitHub repository created by GitHub Classroom. No credit will be awarded for any course work that you submit to the incorrect GitHub repository.\nLabs are graded based on gatorgrade scores and other criteria.\n\nFifty percent of the grade of each Lab is determined by the percentage of gatorgrade checks passed.\nOne quarter of the grade is determined by code correctness following a rubric.\nOne quarter of the grade is determined by professional skills and presentation following a rubric. Professional presentation is impacted by linting, formatting, testing, profiling, duplication avoidance, commenting, markdown styling and communication in reflections.\n\nActivities Nearly weekly, we will have an activity for which points in the course may be earned. Please be sure to turn in activities by the due date as they cannot be made up at a later time."
  },
  {
    "objectID": "syllabus/syllabus.html#discord",
    "href": "syllabus/syllabus.html#discord",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Discord",
    "text": "Discord\nThe instructor will be using Discord to pass important information along to the class, such as code, news and other details. Please actively check your Discord each day to ensure that you are up-to-date with course events."
  },
  {
    "objectID": "syllabus/syllabus.html#additional-policies",
    "href": "syllabus/syllabus.html#additional-policies",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Additional Policies",
    "text": "Additional Policies\n\nAttendance\nStudents are expected to come to class prepared, on time, and to stay engaged for the duration of the class period. This includes both class and lab sessions. This behavior is core to our shared departmental values and is in addition to the college‚Äôs attendance policy.\nEach day of class, please complete the attendance form.\n\nPreparedness\nComing to class prepared means coming with everything you need to engage in a class session. To satisfy basic expectations of CIS courses, this means, at minimum, that students must:\n\narrive at class with a fully charged laptop\nbring their laptop charger or a battery pack so as to ensure that their laptop works throughout the entire class session\ncomplete any pre-session work such as readings and preparatory assignments\n\n\n\nAttendance and Lateness\nOne missed class or lab session counts as one absence. Coming to class/lab late, leaving early, or missing a large portion of a class/lab session will result in your being marked as ‚Äúlate‚Äù to class. Coming to class/lab unprepared may also result in being marked ‚Äúlate‚Äù. Being marked ‚Äúlate‚Äù to class three times during the course of a semester is equal to one absence.\nExcluding the first week of the semester, students can have eight absences without any impact to their grade. These accommodations are meant to cover illness and emergency, so you should always come to class if you are able to do so.\nAs a general guideline, students cannot miss more than two weeks of class in total throughout the academic semester without receiving a letter grade reduction.\nFor this course, excluding the first week and eight excused absences, overall course grade will go down by 1/3 of a letter grade for each additional absence or absence equivalence regardless of base grade.\n\n\nEngagement\nThe term ‚Äúengagement‚Äù or our expectation that students remain ‚Äúengaged‚Äù can mean many things, often varying by course. Baseline behaviors that indicate engagement include:\n\nparticipation in class activities and discussions\ndefined contribution to class sessions in full-class or group discussions\nnote-taking (physical or digital)\nparticipating in course session attendance requirements\nnot participating in non-course related activities\nnot completing non-course related projects\n\n\n\n\nLate Work Policy\nThe deadlines for assignments are hard deadlines. This policy is intended to ensure that students keep up with course topics, are able to actively participate in class, and are accountable for managing time effectively.\nAll students in the CIS department are expected to turn in assignments on time. ‚ÄúOn time‚Äù means on or before the assignment‚Äôs due date. This means that an assignment cannot be turned in for credit after a due date, unless the student applies a token.\n\nTokens\nStudents in 101 are allotted four tokens to receive extensions on any assignment except the final with no questions asked by the course instructor except either in the rare cases of documented severe and/or extenuating circumstances or in cases that violate the CIS policy document or any College-approved policy.\nA token may be applied via a Google Form up to the assignment deadline, with exceptions granted only for severe and/or extenuating circumstances.\nTokens grant an automatic extension of one week to anything except the final exam.\nToken Form for Automatic Extension\n\n\n\nExtenuating Circumstances\nExtenuating circumstances are exceptional, unforeseen, outside of your control, and short-term, like illness and emergency. Regular circumstances associated with taking courses at Allegheny College are not considered extenuating.\nThe accommodations provided by tokens and permitted absences are meant to cover extenuating circumstances like illness, emergency, and work. However, if you have a contagious illness like COVID-19, the flu, or a cold, you should not come to class. If you have expended all your absences and tokens and are still sick with a contagious illness, you may contact your professor about options. If your symptoms are mild or you are recovering from a respiratory illness, we recommend that you wear a mask to class.\nProfessor must be informed of all athletic obligations at the beginning of the semester, or with as much notice as possible. If you are feeling healthy and well, you should make every effort to come to class on time and to complete assignments, rather than using absences and tokens you may need later.\nThese no-questions-asked accommodations are meant to protect student privacy, and to remove the additional effort of acquiring documentation under duress of illness or emergency. In addition, they allow the professor to remain focused on teaching rather than adjudicating excuses.\nIf extenuating circumstances are severe enough to require more absences and tokens, you may contact your professor to discuss options. In most cases, however, a situation of this gravity warrants a request for a ‚ÄúLate Drop‚Äù or ‚ÄúIncomplete‚Äù in the course, as the student will not have had adequate opportunity to learn the material."
  },
  {
    "objectID": "syllabus/syllabus.html#communications",
    "href": "syllabus/syllabus.html#communications",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Communications",
    "text": "Communications\n\nUsing GitHub and Discord\nThis course will primarily use GitHub and Discord for collaborative course communication. Communications that are not private matters must take place in the Data Structures Channel in Discord.\nThe Allegheny College Computer and Information Science Discord Server will also have useful announcements about departmental activities including TL office hours.\n\n\nUsing Email\nAlthough we will primarily use Discord for class communication, the course instructor will sometimes use email to send announcements about important matters such as changes in the schedule. It is your responsibility to check your email at least once a day and to ensure that you can reliably send and receive emails."
  },
  {
    "objectID": "syllabus/syllabus.html#honor-code",
    "href": "syllabus/syllabus.html#honor-code",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Honor Code",
    "text": "Honor Code\nThe Academic Honor Program that governs the entire academic program at Allegheny College is described in the Allegheny Academic Bulletin. The Honor Program applies to all work that is submitted for academic credit or to meet non-credit requirements for graduation at Allegheny College. This includes all work assigned for this class (e.g., examinations and course assignments). All students who have enrolled in the College will work under the Honor Program. Each student who has matriculated at the College has acknowledged the following Honor Code pledge:\n\nI hereby recognize and pledge to fulfill my responsibilities, as defined in the Honor Code, and to maintain the integrity of both myself and the College community as a whole.\n\n\nEffective Collaboration\nComputer science is an inherently collaborative discipline. The Department of Computer and Information Science at Allegheny College encourages students to engage in collaboration. However, in the context of individual coursework, through which each student must demonstrate their own knowledge, there are certain forms of collaboration that are and are not acceptable.\n\nAcceptable forms of collaboration include:\n\nDiscussing high-level concepts.\nReferring someone to a course text book, course slides, example programs, or other resources that contain helpful information or instructions.\nOutlining the high-level steps to solving a problem, without mentioning specific\nlines of code that need to be written.\n\nUnacceptable forms of collaboration include:\n\nSharing details about specific lines of code, including showing your source code to someone or looking at someone else‚Äôs code.\nCopying someone else‚Äôs source code, technical writing, program commands, or program output, even with some slight modifications.\nTyping source code, technical writing, or commands on someone else‚Äôs computer.\n\n\n\n\nPlagiarism and Artificial Intelligence\nStudents may not pass off or represent the work of another student, or their own prior work, as their own current work in any case. Plagiarism and AI-generated code, text, or images are not permitted in any assignment type unless the instructions supplied for the assignment explicitly state otherwise.For exams and all other coursework, students are expected to adhere to the given instructions for the particular exam or item of coursework. It is the responsibility of the student to review the authorization specifications on every item and act appropriately, upholding the honor code. Suspected plagiarized or unauthorized use of AI to generate the work that is turned in will be reported to the Honor Code Committee. This policy does not preclude the use of AI to learn."
  },
  {
    "objectID": "syllabus/syllabus.html#educational-accommodations",
    "href": "syllabus/syllabus.html#educational-accommodations",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Educational Accommodations",
    "text": "Educational Accommodations\nThe Americans with Disabilities Act (ADA) is a federal anti-discrimination statute that provides comprehensive civil rights protection for persons with disabilities. Among other things, this legislation requires all students with disabilities be guaranteed a learning environment that provides for reasonable accommodation of their disabilities. Students with disabilities who believe they may need accommodations in this class are encouraged to contact Student Accessibility and Support Services (SASS) at 814-332-2898. Student Accessibility and Support Services is part of the Learning Commons and is located in Pelletier Library. Please do this as soon as possible to ensure that approved accommodations are implemented in a timely fashion."
  },
  {
    "objectID": "syllabus/syllabus.html#syllabus-changes",
    "href": "syllabus/syllabus.html#syllabus-changes",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Syllabus Changes",
    "text": "Syllabus Changes\nThe instructor may make updates or changes to this document at any time as needed until term grades are due. Changes will be announced to the class."
  },
  {
    "objectID": "utils/interactivePython.html",
    "href": "utils/interactivePython.html",
    "title": "Interactive Python Playground",
    "section": "",
    "text": "Welcome! Enter your Python code below, run it, and save it to your computer.\n\n\nIf you need a notebook for your work, maybe try JupyterLite!\nNote: All saved files are in the cookies and are therefore temporary. To get around this, please download the files from the Jupyter notebook to your local machine.\n\n\n‚ñ∂ Run Code üíæ Save Code üìÇ Load Code ‚ûï Insert Fibonacci Example üßπ Clear üîç+ Larger Font üîç- Smaller Font\n\n\nOutput will appear here."
  },
  {
    "objectID": "utils/interactivePython.html#python-playground",
    "href": "utils/interactivePython.html#python-playground",
    "title": "Interactive Python Playground",
    "section": "",
    "text": "Welcome! Enter your Python code below, run it, and save it to your computer.\n\n\nIf you need a notebook for your work, maybe try JupyterLite!\nNote: All saved files are in the cookies and are therefore temporary. To get around this, please download the files from the Jupyter notebook to your local machine.\n\n\n‚ñ∂ Run Code üíæ Save Code üìÇ Load Code ‚ûï Insert Fibonacci Example üßπ Clear üîç+ Larger Font üîç- Smaller Font\n\n\nOutput will appear here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "",
    "text": "Class Sessions: MWF 10:00 AM to 10:50 AM, Alden 101\nLaboratory Session: Thursday, 2:30 PM to 4 PM, Alden 101\nInstructor: Dr.¬†Bonham-Carter, obonhamcarter@allegheny.edu\nOffice Location: Alden Hall 203\nInstructor Office Hours: Visit the below URL to find availability and schedule and appointment. https://www.oliverbonhamcarter.com/contactandabout/\nBook An Appointment!: https://calendar.app.google/dEK6MftNGNLV1Ft96\nNote: If the office hours times are not convenient, then please reach out to me and we can find an alternative time to meet."
  },
  {
    "objectID": "index.html#quick-links",
    "href": "index.html#quick-links",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Quick Links",
    "text": "Quick Links\n\nThe attendance form\nToken Form for Automatic Extension"
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Course Description",
    "text": "Course Description\nA continuation of CMPSC 100 with an emphasis on implementing, using, and evaluating the computational structures needed to efficiently store and retrieve digital data. Participating in hands-on activities that often require teamwork, students create data structures and algorithms whose correctness and performance they study through proofs and experimentation. Students continue to refine their ability to organize and document a program‚Äôs source code so that it effectively communicates with the intended users and maintainers. During a weekly laboratory session, students use state-of-the-art technology to complete projects, reporting on their results through both written documents and oral presentations.\nQuantitative Reasoning (QR): Quantitative Reasoning is the ability to understand, investigate, communicate, and contextualize numerical, symbolic, and graphical information towards the exploration of natural, physical, behavioral, or social phenomena.\nScientific Process and Knowledge (SP): Courses involving Scientific Process and Knowledge aim to convey an understanding of what is known or can be known about the natural world; apply scientific reasoning towards the analysis and synthesis of scientific information; and create scientifically literate citizens who can engage productively in problem solving.\n\nPrerequisite: CMPSC 100 or permission of the instructor.\nDistribution Requirements: QR, SP."
  },
  {
    "objectID": "index.html#course-learning-objectives",
    "href": "index.html#course-learning-objectives",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Course Learning Objectives",
    "text": "Course Learning Objectives\n\nWhen solving a problem with a Python program, accurately describe data structures and algorithms and their inherent trade-offs.\nUse data structures and algorithms to correctly and efficiently solve a problem through the use of a Python program.\nUse empirical methods to characterize the performance of a Python program that uses data structures and algorithms.\nUse industry-standard practices, such as testing and debugging, and professional-grade integrated development environments (IDEs), command-line tools, and version control systems to implement Python programs.\nImplement Python programs and documentation that conforms to industry-standard formats and styles.\n\nLearning Outcome QR: Students who successfully complete this requirement will demonstrate an understanding of how to interpret numeric data and/or their graphical or symbolic representations.\nLearning Outcome SP: Students who successfully complete this requirement will demonstrate an understanding of the nature, approaches, and domain of scientific inquiry."
  },
  {
    "objectID": "index.html#materials",
    "href": "index.html#materials",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Materials",
    "text": "Materials\n\nTextbook\nIntroduction to Computation and Programming Using Python by John V. Guttag\n\n\n\nOnline Resources and Course Materials\n\nW3schools  \nCourse GitHub Organization\nJupyter Notebooks Directory\nGuttag Textbook Publisher Preview\nGuttag Textbook Google Previews\nAdditional Guttag Textbook Availability\nGuttag Lectures\nPython Docs Proactive Programmers\n\n\n\nSelected Software and Technologies\nWe will be using the following technologies in class.\n\nVSCode\nPython 3.12 or later\npipx\nPoetry\nGatorgrade\nGit\nFree GitHub Account\nFree Discord Account\nAllegheny College Email\n\n\n\nGrading\n\n\nGradebook Repository\nGradeBook repository will be used to deliver your grades from your activities and labs to you. In this repository, you will find a file which contains the same information that the instructor has in the gradebook. While it is a repository that you will pull from, you will never need to push anything to this repository.\nPlease use the following URL to create your gradebook repository; https://classroom.github.com/a/34hXX52q.\n\nGrading Scale\n\n\n\n\n\n\n\n\n\n\n\n\nLetter\nRange\nLetter\nRange\nLetter\nRange\n\n\n\n\nA\n96 - 100\nA-\n90 - 95.9\n\n\n\n\nB+\n87 - 89.9\nB\n83 - 86.9\nB-\n80 - 82.9\n\n\nC+\n77 - 79.9\nC\n73 - 76.9\nC-\n70 - 72.9\n\n\nD+\n67 - 69.9\nD\n63 - 66.9\nF\n59.9 and below\n\n\n\n\n\nBenchmarks\nThe grade that a student receives in this class will be based on the following categories. All percentages are approximate and, if the need to do so presents itself, it is possible for the assigned percentages to change during the academic semester.\n\n\n\nCategory\nPercentage\nAssessment metric\n\n\n\n\nClass Participation and Activities\n20%\ncheck mark grade\n\n\nLabs\n40%\nletter grade\n\n\nMidterm Exam\n20%\nletter grade\n\n\nFinal Project\n20%\nletter grade\n\n\nTotal\n100%\n\n\n\n\n\n\nDefinitions of Grading Categories\n\nClass Participation: All students are required to actively participate during all of the class sessions. Your participation will take forms such as answering questions about the required reading assignments, completing in-class exercises, asking constructive questions of the other members of the class, giving presentations, leading a discussion session in class.% and in the course‚Äôs Slack channels.\nActivities: These assignments invite students to explore different techniques for rigorously designing, implementing, programming, evaluating, and documenting real-world Python programs. These assignments will invite students to use tools like a text editor, a terminal window, and a modern Python development environment to implement functions that strike the right balance between understandability, generalizability, and specialization. Students will also use the data collected from running experiments to evaluate the implementation of a Python function as they consider, for instance, its efficiency and correctness. Knowledge gained from the class and the textbook will be integral to the completion of these projects. Unless other information is given about a due date, activities are to be completed by the end of class.\nExams: The exams will cover all of the material in their associated module(s). The finalized date for each of the exams will be announced at least one week in advance of the scheduled date. Unless prior arrangements are made with the course instructor, all students will be expected to take these exams on the scheduled date and complete the exams in the stated period of time.\nFinal Project: This project will present you with an opportunity to design and implement a correct and carefully evaluated programming solution for a specific problem. Completion of the final project will require you to apply the knowledge, programming and technical skills that you have acquired during the course. The details for the final project will be given approximately a month before the project due date (during finals week)."
  },
  {
    "objectID": "index.html#schedule-at-a-glance",
    "href": "index.html#schedule-at-a-glance",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Schedule At-A-Glance",
    "text": "Schedule At-A-Glance\n\nWeek One: Software Operations (Guttag Chapter 1)\nWeek Two: Python Foundations (Guttage Chapter 2)\nWeek Three: Numerical Programs (Guttag Chapter 3)\nWeek Four: Function Scope (Guttag Chapter 4)\nWeek Five: Structured Types (Guttag Chapter 5)\nWeek Six: Mutability and Aliasing (Guttag Chapter 5)\nWeek Seven: Recursion (Guttag Chapter 6)\nFall Break (Thursday to Sunday)\nWeek Nine: Modules and Files (Guttag Chapter 7)\nWeek Ten: Testing and Handling Exceptions (Guttag Chapter 8 and 9)\nWeek Eleven: Object-Oriented Programming (Guttag Chapter 10)\nWeek Twelve: Algorithmic Complexity (Guttag Chapter 11)\nWeek Thirteen: Sorting (Guttag Chapter 12)\nWeek Fourteen: Data Structures (Guttag Chapter 12 cont)\nWeek Fifteen: Optimization Problems (Guttag Chapter 14)\nWeek Sixteen: Review\n\n\nFinal Deliverable\n\nWednesday, December 10, 2025 at 9:00 AM (Complete Final Exam Schedule)\nExam Code: G"
  },
  {
    "objectID": "index.html#assignment-policies",
    "href": "index.html#assignment-policies",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Assignment Policies",
    "text": "Assignment Policies\n\nAssignment Submission\nAll graded components of the course are expected to be turned in on time. Due dates are provided on each assignment. Electronic versions of the Engineering and Specification Labs must be submitted to through a student‚Äôs GitHub repository created by GitHub Classroom. No credit will be awarded for any course work that you submit to the incorrect GitHub repository.\nLabs are graded based on gatorgrade scores and other criteria.\n\nFifty percent of the grade of each Lab is determined by the percentage of gatorgrade checks passed.\nOne quarter of the grade is determined by code correctness following a rubric.\nOne quarter of the grade is determined by professional skills and presentation following a rubric. Professional presentation is impacted by linting, formatting, testing, profiling, duplication avoidance, commenting, markdown styling and communication in reflections.\n\nActivities Nearly weekly, we will have an activity for which points in the course may be earned. Please be sure to turn in activities by the due date as they cannot be made up at a later time."
  },
  {
    "objectID": "index.html#discord",
    "href": "index.html#discord",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Discord",
    "text": "Discord\nThe instructor will be using Discord to pass important information along to the class, such as code, news and other details. Please actively check your Discord each day to ensure that you are up-to-date with course events."
  },
  {
    "objectID": "index.html#additional-policies",
    "href": "index.html#additional-policies",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Additional Policies",
    "text": "Additional Policies\n\nAttendance\nStudents are expected to come to class prepared, on time, and to stay engaged for the duration of the class period. This includes both class and lab sessions. This behavior is core to our shared departmental values and is in addition to the college‚Äôs attendance policy.\nEach day of class, please complete the attendance form.\n\nPreparedness\nComing to class prepared means coming with everything you need to engage in a class session. To satisfy basic expectations of CIS courses, this means, at minimum, that students must:\n\narrive at class with a fully charged laptop\nbring their laptop charger or a battery pack so as to ensure that their laptop works throughout the entire class session\ncomplete any pre-session work such as readings and preparatory assignments\n\n\n\nAttendance and Lateness\nOne missed class or lab session counts as one absence. Coming to class/lab late, leaving early, or missing a large portion of a class/lab session will result in your being marked as ‚Äúlate‚Äù to class. Coming to class/lab unprepared may also result in being marked ‚Äúlate‚Äù. Being marked ‚Äúlate‚Äù to class three times during the course of a semester is equal to one absence.\nExcluding the first week of the semester, students can have eight absences without any impact to their grade. These accommodations are meant to cover illness and emergency, so you should always come to class if you are able to do so.\nAs a general guideline, students cannot miss more than two weeks of class in total throughout the academic semester without receiving a letter grade reduction.\nFor this course, excluding the first week and eight excused absences, overall course grade will go down by 1/3 of a letter grade for each additional absence or absence equivalence regardless of base grade.\n\n\nEngagement\nThe term ‚Äúengagement‚Äù or our expectation that students remain ‚Äúengaged‚Äù can mean many things, often varying by course. Baseline behaviors that indicate engagement include:\n\nparticipation in class activities and discussions\ndefined contribution to class sessions in full-class or group discussions\nnote-taking (physical or digital)\nparticipating in course session attendance requirements\nnot participating in non-course related activities\nnot completing non-course related projects\n\n\n\n\nLate Work Policy\nThe deadlines for assignments are hard deadlines. This policy is intended to ensure that students keep up with course topics, are able to actively participate in class, and are accountable for managing time effectively.\nAll students in the CIS department are expected to turn in assignments on time. ‚ÄúOn time‚Äù means on or before the assignment‚Äôs due date. This means that an assignment cannot be turned in for credit after a due date, unless the student applies a token.\n\nTokens\nStudents in 101 are allotted four tokens to receive extensions on any assignment except the final with no questions asked by the course instructor except either in the rare cases of documented severe and/or extenuating circumstances or in cases that violate the CIS policy document or any College-approved policy.\nA token may be applied via a Google Form up to the assignment deadline, with exceptions granted only for severe and/or extenuating circumstances.\nTokens grant an automatic extension of one week to anything except the final exam.\nToken Form for Automatic Extension\n\n\n\nExtenuating Circumstances\nExtenuating circumstances are exceptional, unforeseen, outside of your control, and short-term, like illness and emergency. Regular circumstances associated with taking courses at Allegheny College are not considered extenuating.\nThe accommodations provided by tokens and permitted absences are meant to cover extenuating circumstances like illness, emergency, and work. However, if you have a contagious illness like COVID-19, the flu, or a cold, you should not come to class. If you have expended all your absences and tokens and are still sick with a contagious illness, you may contact your professor about options. If your symptoms are mild or you are recovering from a respiratory illness, we recommend that you wear a mask to class.\nProfessor must be informed of all athletic obligations at the beginning of the semester, or with as much notice as possible. If you are feeling healthy and well, you should make every effort to come to class on time and to complete assignments, rather than using absences and tokens you may need later.\nThese no-questions-asked accommodations are meant to protect student privacy, and to remove the additional effort of acquiring documentation under duress of illness or emergency. In addition, they allow the professor to remain focused on teaching rather than adjudicating excuses.\nIf extenuating circumstances are severe enough to require more absences and tokens, you may contact your professor to discuss options. In most cases, however, a situation of this gravity warrants a request for a ‚ÄúLate Drop‚Äù or ‚ÄúIncomplete‚Äù in the course, as the student will not have had adequate opportunity to learn the material."
  },
  {
    "objectID": "index.html#communications",
    "href": "index.html#communications",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Communications",
    "text": "Communications\n\nUsing GitHub and Discord\nThis course will primarily use GitHub and Discord for collaborative course communication. Communications that are not private matters must take place in the Data Structures Channel in Discord.\nThe Allegheny College Computer and Information Science Discord Server will also have useful announcements about departmental activities including TL office hours.\n\n\nUsing Email\nAlthough we will primarily use Discord for class communication, the course instructor will sometimes use email to send announcements about important matters such as changes in the schedule. It is your responsibility to check your email at least once a day and to ensure that you can reliably send and receive emails."
  },
  {
    "objectID": "index.html#honor-code",
    "href": "index.html#honor-code",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Honor Code",
    "text": "Honor Code\nThe Academic Honor Program that governs the entire academic program at Allegheny College is described in the Allegheny Academic Bulletin. The Honor Program applies to all work that is submitted for academic credit or to meet non-credit requirements for graduation at Allegheny College. This includes all work assigned for this class (e.g., examinations and course assignments). All students who have enrolled in the College will work under the Honor Program. Each student who has matriculated at the College has acknowledged the following Honor Code pledge:\n\nI hereby recognize and pledge to fulfill my responsibilities, as defined in the Honor Code, and to maintain the integrity of both myself and the College community as a whole.\n\n\nEffective Collaboration\nComputer science is an inherently collaborative discipline. The Department of Computer and Information Science at Allegheny College encourages students to engage in collaboration. However, in the context of individual coursework, through which each student must demonstrate their own knowledge, there are certain forms of collaboration that are and are not acceptable.\n\nAcceptable forms of collaboration include:\n\nDiscussing high-level concepts.\nReferring someone to a course text book, course slides, example programs, or other resources that contain helpful information or instructions.\nOutlining the high-level steps to solving a problem, without mentioning specific\nlines of code that need to be written.\n\nUnacceptable forms of collaboration include:\n\nSharing details about specific lines of code, including showing your source code to someone or looking at someone else‚Äôs code.\nCopying someone else‚Äôs source code, technical writing, program commands, or program output, even with some slight modifications.\nTyping source code, technical writing, or commands on someone else‚Äôs computer.\n\n\n\n\nPlagiarism and Artificial Intelligence\nStudents may not pass off or represent the work of another student, or their own prior work, as their own current work in any case. Plagiarism and AI-generated code, text, or images are not permitted in any assignment type unless the instructions supplied for the assignment explicitly state otherwise.For exams and all other coursework, students are expected to adhere to the given instructions for the particular exam or item of coursework. It is the responsibility of the student to review the authorization specifications on every item and act appropriately, upholding the honor code. Suspected plagiarized or unauthorized use of AI to generate the work that is turned in will be reported to the Honor Code Committee. This policy does not preclude the use of AI to learn."
  },
  {
    "objectID": "index.html#educational-accommodations",
    "href": "index.html#educational-accommodations",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Educational Accommodations",
    "text": "Educational Accommodations\nThe Americans with Disabilities Act (ADA) is a federal anti-discrimination statute that provides comprehensive civil rights protection for persons with disabilities. Among other things, this legislation requires all students with disabilities be guaranteed a learning environment that provides for reasonable accommodation of their disabilities. Students with disabilities who believe they may need accommodations in this class are encouraged to contact Student Accessibility and Support Services (SASS) at 814-332-2898. Student Accessibility and Support Services is part of the Learning Commons and is located in Pelletier Library. Please do this as soon as possible to ensure that approved accommodations are implemented in a timely fashion."
  },
  {
    "objectID": "index.html#syllabus-changes",
    "href": "index.html#syllabus-changes",
    "title": "CMPSC101 Fall 2025 :: DataStructures",
    "section": "Syllabus Changes",
    "text": "Syllabus Changes\nThe instructor may make updates or changes to this document at any time as needed until term grades are due. Changes will be announced to the class."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "lessons/lessons.html",
    "href": "lessons/lessons.html",
    "title": "Listings",
    "section": "",
    "text": "Here you will find a listing of interactive lessons for the course.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nActivity: Getting To Know You\n\n\n\n\n\n\n\n\n\n\n\nAug 26, 2025\n\n\nOBC\n\n\n\n\n\n\n\n\n\n\n\n\nJust For Fun: Fibonacci Sequence\n\n\nThree Approaches to Computing the Famous Sequence\n\n\n\n\n\n\n\n\nAug 22, 2025\n\n\nOBC\n\n\n\n\n\n\n\n\n\n\n\n\nJust For Fun: String Cheese Demo\n\n\nTesting the simplified lesson template\n\n\n\n\n\n\n\n\nAug 22, 2025\n\n\nOBC\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "lessons/fibonacci.html",
    "href": "lessons/fibonacci.html",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "",
    "text": "Lesson Objectives\n\n\n\nBy the end of this lesson, you will be able to:\n\nUnderstand the mathematical definition of the Fibonacci sequence\nImplement recursive Fibonacci calculation\nCreate an iterative Fibonacci algorithm\nApply Binet‚Äôs formula for direct Fibonacci computation"
  },
  {
    "objectID": "lessons/fibonacci.html#introduction",
    "href": "lessons/fibonacci.html#introduction",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Introduction",
    "text": "Introduction\nThe Fibonacci sequence is one of the most famous sequences in mathematics, appearing in nature, art, and computer science. Each number is the sum of the two preceding ones: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144‚Ä¶\nIn this lesson, we‚Äôll explore three different computational approaches to generate Fibonacci numbers, each with unique advantages and trade-offs."
  },
  {
    "objectID": "lessons/fibonacci.html#key-concepts",
    "href": "lessons/fibonacci.html#key-concepts",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Key Concepts",
    "text": "Key Concepts\n\n\nüí° Concept 1: Mathematical Definition\n\nThe Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n &gt; 1\nThis recursive definition leads naturally to our first implementation approach.\nExample:\n# Mathematical definition\n# F(5) = F(4) + F(3) = 5\n# F(4) = F(3) + F(2) = 3 \n# F(3) = F(2) + F(1) = 2\n\n\n\nüí° Concept 2: Computational Complexity\n\nDifferent algorithms have different time complexities: - Recursive: O(2^n) - exponential, very slow for large n - Iterative: O(n) - linear, efficient for reasonable n - Binet‚Äôs Formula: O(1) - constant time, but limited by floating-point precision\nExample:\n# Time comparison for F(40):\n# Recursive: ~1.6 billion operations\n# Iterative: ~40 operations  \n# Binet's: ~5 operations"
  },
  {
    "objectID": "lessons/fibonacci.html#interactive-examples",
    "href": "lessons/fibonacci.html#interactive-examples",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Interactive Examples",
    "text": "Interactive Examples\n\nExample 1: Recursive Fibonacci\n\nWhat this code does: This implements the mathematical definition directly using recursion. Each function call splits into two more calls, creating a tree-like computation structure. While elegant, it‚Äôs very inefficient for large numbers.\n\nExample Code:\ndef fibonacci_recursive(n):\n    \"\"\"Calculate Fibonacci number using recursion\"\"\"\n    if n &lt;= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\n\n# Test with small numbers (try 10, 15, 20)\nfor i in range(11):\n    print(f'F({i}) = {fibonacci_recursive(i)}')\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\ndef fibonacci_recursive(n):\n    \"\"\"Calculate Fibonacci number using recursion\"\"\"\n    if n &lt;= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\n\n# Test with small numbers (try 10, 15, 20)\nfor i in range(11):\n    print(f'F({i}) = {fibonacci_recursive(i)}')\n\n‚ñ∂ Run Code üóë Clear üîç+ Larger Font üîç- Smaller Font\n\n\nExample 2: Iterative Fibonacci\n\nWhat this code does: This approach builds up the sequence from the bottom, keeping track of only the last two numbers. It‚Äôs much more efficient than recursion, using O(n) time and O(1) space.\n\nExample Code:\ndef fibonacci_iterative(n):\n    \"\"\"Calculate Fibonacci number using iteration\"\"\"\n    if n &lt;= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Test with larger numbers (try 50, 100)\nfor i in [10, 20, 30, 40, 50]:\n    print(f'F({i}) = {fibonacci_iterative(i)}')\n\n# Show the sequence\nprint(\"\\nFirst 20 Fibonacci numbers:\")\nfib_sequence = [fibonacci_iterative(i) for i in range(20)]\nprint(fib_sequence)\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\ndef fibonacci_iterative(n):\n    \"\"\"Calculate Fibonacci number using iteration\"\"\"\n    if n &lt;= 1:\n        return n\n    \n    a, b = 0, 1\n    for i in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Test with larger numbers (try 50, 100)\nfor i in [10, 20, 30, 40, 50]:\n    print(f'F({i}) = {fibonacci_iterative(i)}')\n\n# Show the sequence\nprint(\"\\nFirst 20 Fibonacci numbers:\")\nfib_sequence = [fibonacci_iterative(i) for i in range(20)]\nprint(fib_sequence)\n\n‚ñ∂ Run Code üóë Clear\n\n\nExample 3: Binet‚Äôs Formula\n\nWhat this code does: This uses Binet‚Äôs closed-form formula to calculate Fibonacci numbers directly using the golden ratio. It‚Äôs mathematically elegant and theoretically O(1), but limited by floating-point precision for very large numbers.\n\nExample Code:\nimport math\n\ndef fibonacci_binet(n):\n    \"\"\"Calculate Fibonacci number using Binet's formula\"\"\"\n    if n &lt;= 1:\n        return n\n    \n    # Golden ratio\n    phi = (1 + math.sqrt(5)) / 2\n    psi = (1 - math.sqrt(5)) / 2\n    \n    # Binet's formula\n    result = (phi**n - psi**n) / math.sqrt(5)\n    return round(result)\n\n# Test Binet's formula\nprint(\"Binet's Formula Results:\")\nfor i in range(15):\n    print(f'F({i}) = {fibonacci_binet(i)}')\n\n# Compare accuracy with iterative method\nprint(\"\\nAccuracy comparison (Binet vs Iterative):\")\nfor i in [20, 30, 40, 50]:\n    binet_result = fibonacci_binet(i)\n    iterative_result = fibonacci_iterative(i)\n    match = \"‚úì\" if binet_result == iterative_result else \"‚úó\"\n    print(f'F({i}): Binet={binet_result}, Iterative={iterative_result} {match}')\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\nimport math\n\ndef fibonacci_binet(n):\n    \"\"\"Calculate Fibonacci number using Binet's formula\"\"\"\n    if n &lt;= 1:\n        return n\n    \n    # Golden ratio\n    phi = (1 + math.sqrt(5)) / 2\n    psi = (1 - math.sqrt(5)) / 2\n    \n    # Binet's formula\n    result = (phi**n - psi**n) / math.sqrt(5)\n    return round(result)\n\n# Test Binet's formula\nprint(\"Binet's Formula Results:\")\nfor i in range(15):\n    print(f'F({i}) = {fibonacci_binet(i)}')\n\n# Compare accuracy with iterative method\nprint(\"\\nAccuracy comparison (Binet vs Iterative):\")\nfor i in [20, 30, 40, 50]:\n    binet_result = fibonacci_binet(i)\n    iterative_result = fibonacci_iterative(i)\n    match = \"‚úì\" if binet_result == iterative_result else \"‚úó\"\n    print(f'F({i}): Binet={binet_result}, Iterative={iterative_result} {match}')\n\n‚ñ∂ Run Code üóë Clear\n\n\nChallenge Yourself\n\nPerformance Comparison Challenge\nNow that you‚Äôve seen all three methods, let‚Äôs compare their performance! Try running this timing comparison to see the dramatic differences between approaches:\nChallenge Code:\nimport time\n\n# Time comparison for different methods\ndef time_function(func, n):\n    start = time.time()\n    result = func(n)\n    end = time.time()\n    return result, end - start\n\n# Test with a moderate number (careful with recursive!)\ntest_n = 30\nprint(f\"Computing F({test_n}) with different methods:\\n\")\n\n# Iterative (fast)\nresult, duration = time_function(fibonacci_iterative, test_n)\nprint(f\"Iterative: {result} (took {duration:.6f} seconds)\")\n\n# Binet's formula (very fast)\nresult, duration = time_function(fibonacci_binet, test_n)\nprint(f\"Binet's:   {result} (took {duration:.6f} seconds)\")\n\n# Recursive (slow - be patient!)\nprint(\"\\nRecursive method running... (this will take a while)\")\nresult, duration = time_function(fibonacci_recursive, test_n)\nprint(f\"Recursive: {result} (took {duration:.6f} seconds)\")\n\nprint(\"\\nüéØ Challenge: Try changing test_n to see how each method scales!\")\nprint(\"   - Iterative & Binet's can handle n=50+ easily\")\nprint(\"   - Recursive becomes very slow after n=35\")\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\nimport time\n\n# Time comparison for different methods\ndef time_function(func, n):\n    start = time.time()\n    result = func(n)\n    end = time.time()\n    return result, end - start\n\n# Test with a moderate number (careful with recursive!)\ntest_n = 30\n\nprint(f\"Computing F({test_n}) with different methods:\\n\")\n\n# Iterative (fast)\nresult, duration = time_function(fibonacci_iterative, test_n)\nprint(f\"Iterative: {result} (took {duration:.6f} seconds)\")\n\n# Binet's formula (very fast)\nresult, duration = time_function(fibonacci_binet, test_n)\nprint(f\"Binet's:   {result} (took {duration:.6f} seconds)\")\n\n# Recursive (slow - be patient!)\nprint(\"\\nRecursive method running... (this will take a while)\")\nresult, duration = time_function(fibonacci_recursive, test_n)\nprint(f\"Recursive: {result} (took {duration:.6f} seconds)\")\n\nprint(\"\\nüéØ Challenge: Try changing test_n to see how each method scales!\")\nprint(\"   - Iterative & Binet's can handle n=50+ easily\")\nprint(\"   - Recursive becomes very slow after n=35\")\n\n‚ñ∂ Run Code üóë Clear\n\n\nYour Turn!\n\nChallenge Tasks:\n\nModify the recursive function to use memoization (caching previous results) to make it faster\nCreate a function that generates the first n Fibonacci numbers using your preferred method\nInvestigate the golden ratio - calculate œÜ (phi) from consecutive Fibonacci numbers: F(n+1)/F(n)\nResearch question: Why does Binet‚Äôs formula eventually become inaccurate for very large numbers?\n\nUse any of the terminals above to experiment with these challenges!\n\n\n\nSummary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored three different approaches to computing Fibonacci numbers:\n\nRecursive Implementation: Elegant but exponentially slow (O(2^n)) - demonstrates the mathematical definition directly\nIterative Implementation: Efficient and practical (O(n) time, O(1) space) - builds solutions step-by-step\n\nBinet‚Äôs Formula: Mathematically beautiful (O(1) but limited by precision) - uses the golden ratio for direct calculation\nPerformance Analysis: Understanding how algorithm choice dramatically affects execution time\n\n\n\n\n\nKey Takeaways\nEach approach teaches us different programming and mathematical concepts: - Recursion and why it can be inefficient without optimization (memoization) - Iteration and the power of building solutions incrementally - Mathematical formulas and their computational trade-offs between elegance and precision - Algorithm complexity and how it affects real-world performance\nThe Fibonacci sequence appears everywhere in nature and mathematics, making it a perfect example for understanding both algorithmic thinking and mathematical beauty in programming!\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nFibonacci Numbers in Nature\nGolden Ratio and Mathematics\nAlgorithm Complexity Guide"
  },
  {
    "objectID": "lessons/fibonacci.html#challenge-yourself",
    "href": "lessons/fibonacci.html#challenge-yourself",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Challenge Yourself",
    "text": "Challenge Yourself\n\nPerformance Comparison Challenge\nNow that you‚Äôve seen all three methods, let‚Äôs compare their performance! Try running this timing comparison to see the dramatic differences between approaches:\nChallenge Code:\nimport time\n\n# Time comparison for different methods\ndef time_function(func, n):\n    start = time.time()\n    result = func(n)\n    end = time.time()\n    return result, end - start\n\n# Test with a moderate number (careful with recursive!)\ntest_n = 30\nprint(f\"Computing F({test_n}) with different methods:\\n\")\n\n# Iterative (fast)\nresult, duration = time_function(fibonacci_iterative, test_n)\nprint(f\"Iterative: {result} (took {duration:.6f} seconds)\")\n\n# Binet's formula (very fast)\nresult, duration = time_function(fibonacci_binet, test_n)\nprint(f\"Binet's:   {result} (took {duration:.6f} seconds)\")\n\n# Recursive (slow - be patient!)\nprint(\"\\nRecursive method running... (this will take a while)\")\nresult, duration = time_function(fibonacci_recursive, test_n)\nprint(f\"Recursive: {result} (took {duration:.6f} seconds)\")\n\nprint(\"\\nüéØ Challenge: Try changing test_n to see how each method scales!\")\nprint(\"   - Iterative & Binet's can handle n=50+ easily\")\nprint(\"   - Recursive becomes very slow after n=35\")\n\n\n\n\n\n\n\nLoading Python interpreter‚Ä¶\n\n\n\n\n\nimport time\n\n# Time comparison for different methods\ndef time_function(func, n):\n    start = time.time()\n    result = func(n)\n    end = time.time()\n    return result, end - start\n\n# Test with a moderate number (careful with recursive!)\ntest_n = 30\n\nprint(f\"Computing F({test_n}) with different methods:\\n\")\n\n# Iterative (fast)\nresult, duration = time_function(fibonacci_iterative, test_n)\nprint(f\"Iterative: {result} (took {duration:.6f} seconds)\")\n\n# Binet's formula (very fast)\nresult, duration = time_function(fibonacci_binet, test_n)\nprint(f\"Binet's:   {result} (took {duration:.6f} seconds)\")\n\n# Recursive (slow - be patient!)\nprint(\"\\nRecursive method running... (this will take a while)\")\nresult, duration = time_function(fibonacci_recursive, test_n)\nprint(f\"Recursive: {result} (took {duration:.6f} seconds)\")\n\nprint(\"\\nüéØ Challenge: Try changing test_n to see how each method scales!\")\nprint(\"   - Iterative & Binet's can handle n=50+ easily\")\nprint(\"   - Recursive becomes very slow after n=35\")\n\n‚ñ∂ Run Code üóë Clear\n\n\nYour Turn!\n\nChallenge Tasks:\n\nModify the recursive function to use memoization (caching previous results) to make it faster\nCreate a function that generates the first n Fibonacci numbers using your preferred method\nInvestigate the golden ratio - calculate œÜ (phi) from consecutive Fibonacci numbers: F(n+1)/F(n)\nResearch question: Why does Binet‚Äôs formula eventually become inaccurate for very large numbers?\n\nUse any of the terminals above to experiment with these challenges!\n\n\n\nSummary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored three different approaches to computing Fibonacci numbers:\n\nRecursive Implementation: Elegant but exponentially slow (O(2^n)) - demonstrates the mathematical definition directly\nIterative Implementation: Efficient and practical (O(n) time, O(1) space) - builds solutions step-by-step\n\nBinet‚Äôs Formula: Mathematically beautiful (O(1) but limited by precision) - uses the golden ratio for direct calculation\nPerformance Analysis: Understanding how algorithm choice dramatically affects execution time\n\n\n\n\n\nKey Takeaways\nEach approach teaches us different programming and mathematical concepts: - Recursion and why it can be inefficient without optimization (memoization) - Iteration and the power of building solutions incrementally - Mathematical formulas and their computational trade-offs between elegance and precision - Algorithm complexity and how it affects real-world performance\nThe Fibonacci sequence appears everywhere in nature and mathematics, making it a perfect example for understanding both algorithmic thinking and mathematical beauty in programming!\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nFibonacci Numbers in Nature\nGolden Ratio and Mathematics\nAlgorithm Complexity Guide"
  },
  {
    "objectID": "lessons/fibonacci.html#summary",
    "href": "lessons/fibonacci.html#summary",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Summary",
    "text": "Summary\n\n\n\n\n\n\nWhat You Learned\n\n\n\nIn this lesson, you explored three different approaches to computing Fibonacci numbers:\n\nRecursive Implementation: Elegant but exponentially slow (O(2^n)) - demonstrates the mathematical definition directly\nIterative Implementation: Efficient and practical (O(n) time, O(1) space) - builds solutions step-by-step\n\nBinet‚Äôs Formula: Mathematically beautiful (O(1) but limited by precision) - uses the golden ratio for direct calculation\nPerformance Analysis: Understanding how algorithm choice dramatically affects execution time"
  },
  {
    "objectID": "lessons/fibonacci.html#key-takeaways",
    "href": "lessons/fibonacci.html#key-takeaways",
    "title": "Just For Fun: Fibonacci Sequence",
    "section": "Key Takeaways",
    "text": "Key Takeaways\nEach approach teaches us different programming and mathematical concepts: - Recursion and why it can be inefficient without optimization (memoization) - Iteration and the power of building solutions incrementally - Mathematical formulas and their computational trade-offs between elegance and precision - Algorithm complexity and how it affects real-world performance\nThe Fibonacci sequence appears everywhere in nature and mathematics, making it a perfect example for understanding both algorithmic thinking and mathematical beauty in programming!\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\nFibonacci Numbers in Nature\nGolden Ratio and Mathematics\nAlgorithm Complexity Guide"
  }
]