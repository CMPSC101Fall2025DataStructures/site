---
title: "Chapter 4: Computational Energy Analysis of Newton's Method"
subtitle: "A Study of the General nth Root Algorithm"
author: "Energy-Efficient Computing Research"
format: 
  revealjs:
    theme: default
    transition: slide
    highlight-style: github
    code-fold: false
    chalkboard: true
    slide-number: true
    background-color: "#fafafa"
    font-size: "1.1em"
    css: |
      .reveal {
        --r-background-color: #fafafa;
        --r-main-color: #2c3e50;
        --r-heading-color: #1e3a8a;
        --r-link-color: #3b82f6;
      }
      .callout-note {
        border-left: 5px solid #3b82f6;
        background: #eff6ff;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
      }
      .callout-tip {
        border-left: 5px solid #059669;
        background: #ecfdf5;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
      }
      .callout-warning {
        border-left: 5px solid #d97706;
        background: #fffbeb;
        padding: 15px;
        margin: 10px 0;
        border-radius: 5px;
      }
      .energy-highlight {
        color: #dc2626;
        font-weight: bold;
      }
      .efficiency-box {
        background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        border: 2px solid #3b82f6;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
      }
      /* Enhance callout titles */
      .callout h2 {
        color: #1e3a8a;
        margin-top: 0;
        font-size: 1.1em;
      }
      /* Better spacing for fragments */
      .fragment {
        margin: 0.5em 0;
      }
---

## Introduction {.smaller}

::: {.callout-note}
## Research Question
How much **computational energy** does Newton's method consume when generalized to find any nth root?
:::

- Newton's method is a powerful algorithm for finding roots
- We've generalized it from square roots to [**any nth root**]{.energy-highlight}
- Why does energy matter?
  - 🔋 Battery life in mobile devices
  - 🌱 Server costs and carbon footprint
  - ⚡ Real-time system constraints
  - 📱 IoT and edge computing limitations

## The General Algorithm {.smaller}

```{python}
#| echo: true
#| eval: false
def newtons_nth_root(n: int, value: float, guess: float = 1.0):
    """Find the nth root of a value using Newton's method"""
    tolerance = 0.0001
    
    while abs(guess**n - value) > tolerance:
        # Newton's formula: y_new = y - f(y)/f'(y)
        # For f(y) = y^n - value:
        guess_new = guess - (guess**n - value) / (n * guess**(n-1))
        guess = guess_new
    
    return guess
```


&nbsp;

::: {.callout-tip}
## Mathematical Foundation
**Quadratic convergence** means errors roughly [square each iteration]{.energy-highlight}!

This exponential error reduction is the key to Newton's energy efficiency.
:::

## Energy Measurement Setup {.smaller}

<center>
![](graphics/strategy_i.png){width=45%}
</center>


::: {.efficiency-box}
**Energy Tracking Strategy**

- Count arithmetic operations per iteration
- Measure wall-clock computation time  
- Track convergence behavior
- Compare across different root degrees
:::

---

```{python}
#| echo: true
#| eval: true
#| output: false

import time

def newtons_nth_root_instrumented(n, value, guess=1.0):
    iterations = 0
    operations_count = 0
    start_time = time.time()
    tolerance = 0.0001
    while abs(guess**n - value) > tolerance:
        iterations += 1
        
        # Count operations per iteration:
        # - guess**n: (n-1) multiplications
        # - guess**(n-1): (n-2) multiplications
        # - Basic arithmetic: 3 operations
        operations_count += (n-1) + (n-2) + 3 + 2
        
        guess = guess - (guess**n - value) / (n * guess**(n-1))
    
    computation_time = time.time() - start_time
    return guess, iterations, computation_time, operations_count

# print the results
results = newtons_nth_root_instrumented(2,144)
print(f"guess : {results[0]}")
print(f"iterations : {results[1]}")
print(f"comp_time : {results[2]}")
print(f"operations : {results[3]}")
```

---


### Results

```{python}
#| echo: true
#| eval: true
#| output: true
results = newtons_nth_root_instrumented(3,27)
print(f"guess : {results[0]}")
print(f"iterations : {results[1]}")
print(f"comp_time : {results[2]}")
print(f"operations : {results[3]}")
```

<!-- &nbsp; -->

```{python}
#| echo: true
#| eval: true
#| output: true
results = newtons_nth_root_instrumented(3,27)
print(f"guess : {results[0]}")
print(f"iterations : {results[1]}")
print(f"comp_time : {results[2]}")
print(f"operations : {results[3]}")
```

---

## Live Demo: Energy Analysis {.smaller}

```{python}
#| echo: true
#| eval: true
import time

def newtons_nth_root(n: int, value: float, guess: float = 1.0, verbose: bool = True) -> tuple:
    """Find the nth root of a value using Newton's method with performance analysis."""
    if n <= 0:
        raise ValueError("n must be a positive integer")
    if value < 0 and n % 2 == 0:
        raise ValueError("Cannot find even root of negative number")
    
    tolerance = 0.0001
    iterations = 0
    operations_count = 0
    start_time = time.time()
    
    while abs(guess**n - value) > tolerance:
        iterations += 1
        
        if verbose:
            print(f"Iter {iterations}: guess = {guess:.4f}, error = {abs(guess**n - value):.6f}")
        
        operations_this_iteration = (n-1) + (n-2) + 3 + 2
        operations_count += operations_this_iteration
        
        guess_new = guess - (guess**n - value) / (n * guess**(n-1))
        guess = guess_new
    
    computation_time = time.time() - start_time
    
    if verbose:
        print(f"✓ Converged in {iterations} iterations")
        print(f"✓ Total operations: {operations_count}")
        print(f"✓ Time: {computation_time:.6f} seconds")
    
    return guess, iterations, computation_time, operations_count
```

---

## Results: Energy Analysis {.smaller}

::: {.callout-note}
## Live Demonstration
Watch Newton's method converge in real-time with energy tracking!
:::

```{python}
#| echo: true
#| eval: false
# Quick demo: Square root of 16
result, iters, time_taken, ops = newtons_nth_root(2, 16, verbose=True)
print(f"Result: {result:.6f}")
```

```{python}
# Quick demo: Square root of 16
result, iters, time_taken, ops = newtons_nth_root(2, 16, verbose=True)
print(f"Result: {result:.6f}")
```

::: {.callout-tip}
## Key Observation
Notice how quickly it converges - only [**2-3 iterations**]{.energy-highlight} for most calculations!
:::

---

### Energy Comp Across Root Degrees {.smaller}

```{python}
#| echo: true
#| eval: true
#| output: false
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import pandas as pd

# Test cases for energy comparison
test_cases = [
    (2, 16, "Square root of 16"), (3, 27, "Cube root of 27"),
    (4, 81, "Fourth root of 81"), (5, 32, "Fifth root of 32"),
    (6, 64, "Sixth root of 64"), (8, 256, "Eighth root of 256"),
    (10, 1024, "Tenth root of 1024"),
]

# Collect data for plotting
data = []
for n, value, description in test_cases:
    result, iterations, time_taken, operations = newtons_nth_root(n, value, verbose=False)
    ops_per_iter = operations / iterations
    data.append({
        'root_degree': n,
        'value': value,
        'description': description,
        'iterations': iterations,
        'operations': operations,
        'ops_per_iter': ops_per_iter,
        'time_seconds': time_taken,
        'result': result
    })

df = pd.DataFrame(data)

# Create interactive subplots
fig = make_subplots(
    rows=2, cols=2,
    subplot_titles=('Total Operations vs Root Degree', 'Iterations vs Root Degree',
                   'Operations per Iteration vs Root Degree', 'Computation Time vs Root Degree'),
    specs=[[{"secondary_y": False}, {"secondary_y": False}],
           [{"secondary_y": False}, {"secondary_y": False}]]
)

# Plot 1: Total Operations vs Root Degree
fig.add_trace(
    go.Scatter(x=df['root_degree'], y=df['operations'],
               mode='markers+lines',
               name='Total Operations',
               text=df['description'],
               marker=dict(size=10, color='blue'),
               line=dict(color='blue', width=3),
               hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Operations: %{y}<extra></extra>'),
    row=1, col=1
)

# Plot 2: Iterations vs Root Degree  
fig.add_trace(
    go.Scatter(x=df['root_degree'], y=df['iterations'],
               mode='markers+lines',
               name='Iterations',
               text=df['description'],
               marker=dict(size=10, color='red'),
               line=dict(color='red', width=3),
               hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Iterations: %{y}<extra></extra>'),
    row=1, col=2
)

# Plot 3: Operations per Iteration vs Root Degree
fig.add_trace(
    go.Scatter(x=df['root_degree'], y=df['ops_per_iter'],
               mode='markers+lines',
               name='Ops/Iteration',
               text=df['description'],
               marker=dict(size=10, color='green'),
               line=dict(color='green', width=3),
               hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Ops/Iter: %{y:.1f}<extra></extra>'),
    row=2, col=1
)

# Plot 4: Computation Time vs Root Degree
fig.add_trace(
    go.Scatter(x=df['root_degree'], y=df['time_seconds']*1000,  # Convert to milliseconds
               mode='markers+lines',
               name='Time (ms)',
               text=df['description'],
               marker=dict(size=10, color='purple'),
               line=dict(color='purple', width=3),
               hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Time: %{y:.3f} ms<extra></extra>'),
    row=2, col=2
)

# Update layout
fig.update_layout(
    title=dict(
        text="<b>Newton's Method: Energy Scaling Analysis</b>",
        x=0.5,
        font=dict(size=18)
    ),
    showlegend=False,
    height=600,
    font=dict(size=12)
)

# Update axes labels
fig.update_xaxes(title_text="Root Degree (n)", row=1, col=1)
fig.update_xaxes(title_text="Root Degree (n)", row=1, col=2)
fig.update_xaxes(title_text="Root Degree (n)", row=2, col=1)
fig.update_xaxes(title_text="Root Degree (n)", row=2, col=2)

fig.update_yaxes(title_text="Total Operations", row=1, col=1)
fig.update_yaxes(title_text="Iterations", row=1, col=2)
fig.update_yaxes(title_text="Operations per Iteration", row=2, col=1)
fig.update_yaxes(title_text="Time (milliseconds)", row=2, col=2)

fig.show()
```

---

### Newton's Method: Energy Scaling Analysis {.smaller}
<!-- #### Interactive Energy Scaling Visualization -->

```{python}
#| echo: false
#| eval: true

# Display the plot on its own slide for better visibility
fig_display = make_subplots(
    rows=2, cols=2,
    subplot_titles=('Total Operations vs Root Degree', 'Iterations vs Root Degree',
                   'Operations per Iteration vs Root Degree', 'Computation Time vs Root Degree'),
    specs=[[{"secondary_y": False}, {"secondary_y": False}],
           [{"secondary_y": False}, {"secondary_y": False}]]
)

# Plot 1: Total Operations vs Root Degree
fig_display.add_trace(
    go.Scatter(x=df['root_degree'], y=df['operations'],
               mode='markers+lines',
               name='Total Operations',
               text=df['description'],
               marker=dict(size=12, color='blue'),
               line=dict(color='blue', width=4),
               hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Operations: %{y}<extra></extra>'),
    row=1, col=1
)

# Plot 2: Iterations vs Root Degree  
fig_display.add_trace(
    go.Scatter(x=df['root_degree'], y=df['iterations'],
               mode='markers+lines',
               name='Iterations',
               text=df['description'],
               marker=dict(size=12, color='red'),
               line=dict(color='red', width=4),
               hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Iterations: %{y}<extra></extra>'),
    row=1, col=2
)

# Plot 3: Operations per Iteration vs Root Degree
fig_display.add_trace(
    go.Scatter(x=df['root_degree'], y=df['ops_per_iter'],
               mode='markers+lines',
               name='Ops/Iteration',
               text=df['description'],
               marker=dict(size=12, color='green'),
               line=dict(color='green', width=4),
               hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Ops/Iter: %{y:.1f}<extra></extra>'),
    row=2, col=1
)

# Plot 4: Computation Time vs Root Degree
fig_display.add_trace(
    go.Scatter(x=df['root_degree'], y=df['time_seconds']*1000,  # Convert to milliseconds
               mode='markers+lines',
               name='Time (ms)',
               text=df['description'],
               marker=dict(size=12, color='purple'),
               line=dict(color='purple', width=4),
               hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Time: %{y:.3f} ms<extra></extra>'),
    row=2, col=2
)

# Enhanced layout for presentation
fig_display.update_layout(
    #title=dict(
    #    text="<b>Newton's Method: Energy Scaling Analysis</b>",
    #    x=0.5,
    #    font=dict(size=15)
    #),
    showlegend=False,
    height=600,
    font=dict(size=14)
)

# Update axes labels with larger fonts
fig_display.update_xaxes(title_text="Root Degree (n)", title_font=dict(size=14), row=1, col=1)
fig_display.update_xaxes(title_text="Root Degree (n)", title_font=dict(size=14), row=1, col=2)
fig_display.update_xaxes(title_text="Root Degree (n)", title_font=dict(size=14), row=2, col=1)
fig_display.update_xaxes(title_text="Root Degree (n)", title_font=dict(size=14), row=2, col=2)

fig_display.update_yaxes(title_text="Total Operations", title_font=dict(size=14), row=1, col=1)
fig_display.update_yaxes(title_text="Iterations", title_font=dict(size=14), row=1, col=2)
fig_display.update_yaxes(title_text="Operations per Iteration", title_font=dict(size=14), row=2, col=1)
fig_display.update_yaxes(title_text="Time (milliseconds)", title_font=dict(size=14), row=2, col=2)

fig_display.show()
```

<!-- ---

**Key Observations**: Hover over data points to explore the relationships between root degree and computational cost! -->

---

## Energy Scaling Summary

```{python}
#| echo: false 
#| eval: true

# Print summary table
print("Interactive Energy Scaling Summary:")
print("=" * 60)
for _, row in df.iterrows():
    print(f"n={row['root_degree']:2}: {row['iterations']:2} iters, {row['operations']:3} ops, "
          f"{row['ops_per_iter']:5.1f} ops/iter, {row['time_seconds']*1000:6.3f}ms")

print(f"\n💡 Key Insights from Interactive Plot:")
print(f"   - Linear scaling: Operations ∝ Root Degree")
print(f"   - Consistent iterations: Usually 2-4 for perfect powers")
print(f"   - Predictable performance: Energy cost is very manageable!")
```

::: {.callout-tip}
## Energy Efficiency Breakthrough! 
[**Linear scaling**]{.energy-highlight} with root degree means predictable energy costs regardless of calculation complexity!
:::

## Key Energy Findings {.smaller}

::: {.columns}

::: {.column width="50%"}
### **Excellent Scaling Properties**
- **Time Complexity**: O(log(precision))
- **Operations per iteration**: O(n)
- **Total Energy**: O(n × log(precision))
- **Independent of input magnitude**!
:::

::: {.column width="50%"}
### **Convergence Characteristics**
- Quadratic convergence rate
- Perfect powers converge faster
- Predictable iteration counts
- Minimal memory usage O(1)
:::

:::

::: {.callout-tip}
## 🏆 Bottom Line
Newton's method is [**remarkably energy-efficient**]{.energy-highlight} due to its quadratic convergence!

**Perfect for**: Mobile apps, IoT devices, real-time systems, and green computing initiatives.
:::

## Energy vs Other Methods {.smaller}

| Method | Time Complexity | Energy Dependency |
|--------|----------------|-------------------|
| **Newton's Method** | O(n × log(precision)) | Independent of input size |
| Binary Search | O(log(value) × log(precision)) | Depends on input magnitude |
| Trial & Error | O(value^(1/n)) | Exponential in input |
| Linear Methods | O(precision) | Poor convergence |

::: {.callout-tip}
## 🏆 Clear Winner: Newton's Method!
[**Independent of input size**]{.energy-highlight} - this is huge for scalability!
:::

## Practical Energy Implications {.smaller}

::: {.efficiency-box}
**🔋 Mobile Devices**: [Fast convergence = longer battery life]{.energy-highlight}

**🌱 Data Centers**: Predictable costs, lower carbon footprint  

**⚡ Real-time Systems**: Bounded computation time

**📟 IoT Devices**: Suitable for resource-constrained environments

**🔬 Scientific Computing**: Efficient for high-precision calculations
:::

::: {.callout-tip}
## Energy Optimization Tips
- Use good initial guesses to reduce iterations
- Adjust tolerance based on precision needs
- Cache results for repeated calculations
- Consider hardware-specific optimizations
:::

## Mathematical Energy Theory {.smaller}

### Convergence Formula
$$\text{Error}_{n+1} \approx \frac{(\text{Error}_n)^2}{2 \cdot f'(\text{root})}$$

### Energy Cost Model
$$\text{Energy} \propto \text{Iterations} \times \text{Operations per Iteration} \times \text{Hardware Efficiency}$$

$$\text{Energy} \propto \log(\text{precision}) \times n \times \text{constant}$$

::: {.callout-note}
## 🧮 Key Mathematical Insight
[**Logarithmic dependence on precision**]{.energy-highlight} makes it incredibly efficient!

Double the precision? Only one more iteration needed!
:::

## Performance Comparison: Setup {.smaller}


```{python}
#| echo: true
#| eval: true

# Enhanced comparison: Perfect vs Non-Perfect Powers
comparison_data = []

# Extended comparison set
comparisons = [
    ((2, 16, "√16 (perfect)"), (2, 15, "√15 (non-perfect)")),
    ((2, 25, "√25 (perfect)"), (2, 24, "√24 (non-perfect)")),
    ((3, 27, "∛27 (perfect)"), (3, 26, "∛26 (non-perfect)")),
    ((3, 64, "∛64 (perfect)"), (3, 63, "∛63 (non-perfect)")),
    ((4, 81, "⁴√81 (perfect)"), (4, 80, "⁴√80 (non-perfect)")),
    ((5, 32, "⁵√32 (perfect)"), (5, 31, "⁵√31 (non-perfect)")),
]

for (n1, v1, desc1), (n2, v2, desc2) in comparisons:
    _, iters1, time1, ops1 = newtons_nth_root(n1, v1, verbose=False)
    _, iters2, time2, ops2 = newtons_nth_root(n2, v2, verbose=False)
    
    comparison_data.extend([
        {'root_degree': n1, 'type': 'Perfect Power', 'description': desc1, 
         'iterations': iters1, 'operations': ops1, 'time_ms': time1*1000},
        {'root_degree': n2, 'type': 'Non-Perfect', 'description': desc2, 
         'iterations': iters2, 'operations': ops2, 'time_ms': time2*1000}
    ])

comp_df = pd.DataFrame(comparison_data)
```

---

::: {.callout-note}
## 🔍 Research Question
Do [**perfect powers**]{.energy-highlight} (like 16, 27, 81) converge faster than non-perfect values?

Let's find out with interactive data!
:::

---

### Perfect vs Non-Perfect Powers

```{python}
#| echo: false
#| eval: true

# Create interactive comparison plot
fig = make_subplots(
    rows=1, cols=2,
    subplot_titles=('Iterations', 
                   'Total Operations'),
    # subplot_titles=('Iterations: Perfect vs Non-Perfect Powers', 
    #                'Total Operations: Perfect vs Non-Perfect Powers'),
    specs=[[{"secondary_y": False}, {"secondary_y": False}]]
)

# Colors for perfect vs non-perfect
colors = {'Perfect Power': 'lightblue', 'Non-Perfect': 'lightcoral'}

# Plot iterations comparison
for power_type in ['Perfect Power', 'Non-Perfect']:
    data_subset = comp_df[comp_df['type'] == power_type]
    fig.add_trace(
        go.Scatter(x=data_subset['root_degree'], y=data_subset['iterations'],
                   mode='markers+lines',
                   name=f'{power_type} - Iterations',
                   text=data_subset['description'],
                   marker=dict(size=12, color=colors[power_type]),
                   line=dict(width=3),
                   hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Iterations: %{y}<extra></extra>'),
        row=1, col=1
    )

# Plot operations comparison  
for power_type in ['Perfect Power', 'Non-Perfect']:
    data_subset = comp_df[comp_df['type'] == power_type]
    fig.add_trace(
        go.Scatter(x=data_subset['root_degree'], y=data_subset['operations'],
                   mode='markers+lines',
                   name=f'{power_type} - Operations',
                   text=data_subset['description'],
                   marker=dict(size=12, color=colors[power_type]),
                   line=dict(width=3),
                   hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Operations: %{y}<extra></extra>'),
        row=1, col=2
    )

fig.update_layout(
    title=dict(
        # text="<b>Energy Impact: Perfect vs Non-Perfect Powers</b>",
        text="<b></b>",
        x=0.5,
        font=dict(size=16)
    ),
    height=400,
    showlegend=True,
    legend=dict(orientation="h", yanchor="bottom", y=-0.3, xanchor="center", x=0.5)
)

fig.update_xaxes(title_text="Root Degree (n)", row=1, col=1)
fig.update_xaxes(title_text="Root Degree (n)", row=1, col=2)
fig.update_yaxes(title_text="Iterations", row=1, col=1)
fig.update_yaxes(title_text="Total Operations", row=1, col=2)

fig.show()


# Summary statistics
perfect_avg_iters = comp_df[comp_df['type'] == 'Perfect Power']['iterations'].mean()
nonperfect_avg_iters = comp_df[comp_df['type'] == 'Non-Perfect']['iterations'].mean()

print(f"\n📊 Perfect vs Non-Perfect Power Analysis:")
print(f"   Average iterations (Perfect Powers): {perfect_avg_iters:.1f}")
print(f"   Average iterations (Non-Perfect): {nonperfect_avg_iters:.1f}")
print(f"   Energy penalty for non-perfect: {((nonperfect_avg_iters/perfect_avg_iters-1)*100):+.1f}%")
print("   💡 Perfect powers converge faster, but the difference is manageable!")
```

---

### What Code Just Made That Plot? {.smaller}

```{python}

#| echo: true
#| eval: true
#| output: false

# Create interactive comparison plot
fig = make_subplots(
    rows=1, cols=2,
    subplot_titles=('Iterations', 
                   'Total Operations'),
    # subplot_titles=('Iterations: Perfect vs Non-Perfect Powers', 
    #                'Total Operations: Perfect vs Non-Perfect Powers'),
    specs=[[{"secondary_y": False}, {"secondary_y": False}]]
)

# Colors for perfect vs non-perfect
colors = {'Perfect Power': 'lightblue', 'Non-Perfect': 'lightcoral'}

# Plot iterations comparison
for power_type in ['Perfect Power', 'Non-Perfect']:
    data_subset = comp_df[comp_df['type'] == power_type]
    fig.add_trace(
        go.Scatter(x=data_subset['root_degree'], y=data_subset['iterations'],
                   mode='markers+lines',
                   name=f'{power_type} - Iterations',
                   text=data_subset['description'],
                   marker=dict(size=12, color=colors[power_type]),
                   line=dict(width=3),
                   hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Iterations: %{y}<extra></extra>'),
        row=1, col=1
    )

# Plot operations comparison  
for power_type in ['Perfect Power', 'Non-Perfect']:
    data_subset = comp_df[comp_df['type'] == power_type]
    fig.add_trace(
        go.Scatter(x=data_subset['root_degree'], y=data_subset['operations'],
                   mode='markers+lines',
                   name=f'{power_type} - Operations',
                   text=data_subset['description'],
                   marker=dict(size=12, color=colors[power_type]),
                   line=dict(width=3),
                   hovertemplate='<b>%{text}</b><br>Root Degree: %{x}<br>Operations: %{y}<extra></extra>'),
        row=1, col=2
    )

fig.update_layout(
    title=dict(
        # text="<b>Energy Impact: Perfect vs Non-Perfect Powers</b>",
        text="<b></b>",
        x=0.5,
        font=dict(size=16)
    ),
    height=400,
    showlegend=True,
    legend=dict(orientation="h", yanchor="bottom", y=-0.3, xanchor="center", x=0.5)
)

fig.update_xaxes(title_text="Root Degree (n)", row=1, col=1)
fig.update_xaxes(title_text="Root Degree (n)", row=1, col=2)
fig.update_yaxes(title_text="Iterations", row=1, col=1)
fig.update_yaxes(title_text="Total Operations", row=1, col=2)

fig.show()


# Summary statistics
perfect_avg_iters = comp_df[comp_df['type'] == 'Perfect Power']['iterations'].mean()
nonperfect_avg_iters = comp_df[comp_df['type'] == 'Non-Perfect']['iterations'].mean()

print(f"\n📊 Perfect vs Non-Perfect Power Analysis:")
print(f"   Average iterations (Perfect Powers): {perfect_avg_iters:.1f}")
print(f"   Average iterations (Non-Perfect): {nonperfect_avg_iters:.1f}")
print(f"   Energy penalty for non-perfect: {((nonperfect_avg_iters/perfect_avg_iters-1)*100):+.1f}%")
print("   💡 Perfect powers converge faster, but the difference is manageable!")
```

---

#### Real-World Energy Impact (I)

::: {.callout-note}
## 📱 Smartphone Calculator App
- Square root calculation: ~10-20 operations
- Battery impact: Negligible (< 0.001%)
- User experience: Instant response
:::

::: {.callout-tip}
## 🖥️ Scientific Computing Cluster
- Million root calculations/second
- Energy efficiency matters at scale
- Newton's method saves significant power
:::

---

#### Real-World Energy Impact (II)


::: {.callout-warning}
## 📟 IoT Sensor Network
- Limited battery life
- Occasional calibration calculations
- Newton's method enables longer deployment
:::

<center>
![](graphics/battery_i.png){width=50%}
</center>

## Conclusion: Why Newton's Method Wins {.smaller}

::: {.incremental}
1. **Quadratic Convergence**: Errors square each iteration
2. **Predictable Energy Cost**: O(n × log(precision))
3. **Scale Independence**: Input magnitude doesn't matter
4. **Hardware Friendly**: Simple arithmetic operations
5. **Memory Efficient**: Constant space complexity
6. **Universally Applicable**: Any nth root with same efficiency
:::

---

::: {.callout-tip}
## 🌟 The Big Picture
Newton's method represents a perfect balance of:

- [**Mathematical elegance**]{.energy-highlight} ✨
- [**Computational efficiency**]{.energy-highlight} ⚡  
- [**Energy consciousness**]{.energy-highlight} 🌱

**Result**: Sustainable, fast, and beautiful mathematics!
:::

## Questions & Discussion {.center}

::: {.r-fit-text}
**How might energy considerations influence algorithm choice in your projects?**
:::

::: {.fragment}
### Try it yourself!
```python
# Experiment with different roots and values
result = newtons_nth_root(7, 128, verbose=True)
```
:::

## Appendix: Complete Implementation {.smaller}

```{python}
#| echo: true
#| eval: false
#| code-fold: true
#| code-summary: "Show complete instrumented function"

def newtons_nth_root_complete(n: int, value: float, guess: float = 1.0, verbose: bool = True) -> tuple:
    """
    Complete instrumented version with full energy analysis
    """
    if n <= 0:
        raise ValueError("n must be a positive integer")
    if value < 0 and n % 2 == 0:
        raise ValueError("Cannot find even root of negative number")
    
    tolerance = 0.0001
    iterations = 0
    operations_count = 0
    start_time = time.time()
    
    while abs(guess**n - value) > tolerance:
        iterations += 1
        
        if verbose:
            print(f"Iteration {iterations}: n = {n}, value = {value}, guess = {guess}")
            print(f"   abs(guess^n - value) = {abs(guess**n - value)}")
        
        # Detailed operation counting
        operations_this_iteration = (n-1) + (n-2) + 3 + 2
        operations_count += operations_this_iteration
        
        guess_new = guess - (guess**n - value) / (n * guess**(n-1))
        
        if verbose:
            print(f"   new_guess = {guess_new}")
            print(f"   Operations this iteration: {operations_this_iteration}")
        
        guess = guess_new
    
    computation_time = time.time() - start_time
    
    if verbose:
        print(f"Convergence in {iterations} iterations")
        print(f"Total operations: {operations_count}")
        print(f"Computation time: {computation_time:.6f} seconds")
    
    return guess, iterations, computation_time, operations_count
```