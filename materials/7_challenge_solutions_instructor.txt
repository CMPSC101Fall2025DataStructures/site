---
title: "Chapter 5: STRUCTURED TYPES AND MUTABILITY"
subtitle: "Python challenges, Instructor Solutions"
author: "CS 101 - Fall 2025"
format:
  html:
    theme: cosmo
    code-fold: false
    toc: true
    toc-location: left
    css: custom_w6.css
---

# Instructor Solution Guide ï¿½

This guide provides complete solutions for all student challenges in the Python Fundamentals activity. Each solution includes the code, expected output, and teaching notes for the **revised, manageable challenges** that students can complete in 10-20 minutes.

---

## Challenge 1: Tuple Practice ðŸŸ¢

### Complete Solution

```python
# Given data
student1 = ("Alice", 85, "Computer Science")
student2 = ("Bob", 92, "Mathematics")
student3 = ("Carol", 78, "Physics")

# Solutions:
# 1. Create a tuple with all three students
all_students = (student1, student2, student3)
# Alternative: all_students = (("Alice", 85, "Computer Science"), ("Bob", 92, "Mathematics"), ("Carol", 78, "Physics"))

# 2. Get Alice's grade (second element of first tuple)
alice_grade = all_students[0][1]  # or student1[1]

# 3. Get all student names in a list
names = [student1[0], student2[0], student3[0]]
# Alternative: names = [student[0] for student in all_students]

# 4. Count how many students have grades above 80
high_grades = sum(1 for student in all_students if student[1] > 80)
# Alternative: high_grades = len([s for s in all_students if s[1] > 80])
```

### Expected Output
```python
print(all_students)  # (('Alice', 85, 'Computer Science'), ('Bob', 92, 'Mathematics'), ('Carol', 78, 'Physics'))
print(alice_grade)   # 85
print(names)         # ['Alice', 'Bob', 'Carol']
print(high_grades)   # 2
```

### Teaching Notes
- **Key Concept**: Tuple indexing and nested tuple access
- **Common Mistakes**: Students may try to modify tuples (impossible!)
- **Extensions**: Ask students why tuples are better than lists for student records

---

## Challenge 2: List Comprehension Magic ï¿½

### Complete Solution

```python
# Given data
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
words = ["apple", "banana", "cherry", "date", "elderberry"]

# Solutions:
# 1. Create a list of squares for even numbers only
even_squares = [x**2 for x in numbers if x % 2 == 0]

# 2. Create a list of words with more than 5 letters, in uppercase
long_words_upper = [word.upper() for word in words if len(word) > 5]

# 3. Create a list of numbers from 1-20 that are divisible by 3
divisible_by_3 = [x for x in range(1, 21) if x % 3 == 0]

# 4. Create a list with first letter of each word
first_letters = [word[0] for word in words]
```

### Expected Output
```python
print(even_squares)        # [4, 16, 36, 64, 100]
print(long_words_upper)    # ['BANANA', 'CHERRY', 'ELDERBERRY']
print(divisible_by_3)      # [3, 6, 9, 12, 15, 18]
print(first_letters)       # ['a', 'b', 'c', 'd', 'e']
```

### Teaching Notes
- **Key Concept**: List comprehension syntax with conditions
- **Common Mistakes**: Forgetting the `if` condition syntax
- **Extensions**: Show equivalent for-loop versions for comparison

---

## Challenge 3: Set Operations ðŸŸ¢

### Complete Solution

```python
# Given data
class_a = {"Alice", "Bob", "Charlie", "David", "Eve"}
class_b = {"Charlie", "David", "Frank", "Grace", "Alice"}
grades = [85, 92, 78, 85, 91, 78, 88, 85, 92, 78]

# Solutions:
# 1. Find students in both classes
both_classes = class_a & class_b
# Alternative: both_classes = class_a.intersection(class_b)

# 2. Find students only in class A
only_class_a = class_a - class_b
# Alternative: only_class_a = class_a.difference(class_b)

# 3. Find all unique grades
unique_grades = set(grades)

# 4. Find total number of unique students
total_students = len(class_a | class_b)
# Alternative: total_students = len(class_a.union(class_b))
```

### Expected Output
```python
print(both_classes)    # {'Alice', 'Charlie', 'David'}
print(only_class_a)    # {'Bob', 'Eve'}
print(unique_grades)   # {78, 85, 88, 91, 92}
print(total_students)  # 7
```

### Teaching Notes
- **Key Concept**: Set operations (intersection, difference, union)
- **Common Mistakes**: Confusing set operators (&, |, -)
- **Extensions**: Discuss performance benefits of sets vs lists for membership testing

---

## Challenge 4: 2D List Basics ðŸŸ¡

### Complete Solution

```python
# Create a 3x3 tic-tac-toe board
board = [
    [' ', ' ', ' '],
    [' ', ' ', ' '],
    [' ', ' ', ' ']
]

# Solutions:
# 1. Place 'X' in the center (row 1, column 1)
board[1][1] = 'X'

# 2. Place 'O' in top-left corner (row 0, column 0)
board[0][0] = 'O'

# 3. Create a list of all positions that are empty (' ')
empty_positions = [(i, j) for i in range(3) for j in range(3) if board[i][j] == ' ']
# Alternative: Use nested loops for clarity

# 4. Check if the center row has any 'X' in it
center_has_x = 'X' in board[1]
# Alternative: center_has_x = any(cell == 'X' for cell in board[1])
```

### Expected Output
```python
print(board)           # [['O', ' ', ' '], [' ', 'X', ' '], [' ', ' ', ' ']]
print(empty_positions) # [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]
print(center_has_x)    # True
```

### Teaching Notes
- **Key Concept**: 2D list indexing and nested comprehensions
- **Common Mistakes**: Confusing row/column order
- **Extensions**: Show how to print the board in a readable format

---

## Challenge 5: List Cloning Practice ðŸŸ¡

### Complete Solution

```python
# Original shopping list
original_list = ["apples", "bananas", "oranges"]

# Solutions:
# 1. Create a proper copy of the original list
shopping_copy = original_list.copy()
# Alternatives: shopping_copy = original_list[:] or list(original_list)

# 2. Add "grapes" to the copy (original should remain unchanged)
shopping_copy.append("grapes")

# 3. Create another copy and remove "bananas" from it
fruit_copy = original_list.copy()
fruit_copy.remove("bananas")

# 4. Verify original list is unchanged
print(f"Original: {original_list}")  # Should be ["apples", "bananas", "oranges"]
```

### Expected Output
```python
print(f"Original: {original_list}")   # ['apples', 'bananas', 'oranges']
print(f"Shopping: {shopping_copy}")   # ['apples', 'bananas', 'oranges', 'grapes']
print(f"Fruit: {fruit_copy}")         # ['apples', 'oranges']
```

### Teaching Notes
- **Key Concept**: Deep vs shallow copying
- **Common Mistakes**: Using assignment (=) instead of .copy()
- **Extensions**: Demonstrate what happens without proper cloning

---

## Challenge 6: Range and Map Practice ðŸŸ¡

### Complete Solution

```python
# Given data
prices = [19.99, 25.50, 12.75, 8.99, 45.00, 15.25]

# Solutions:
# 1. Use range to create a list of numbers 0-9
numbers = list(range(10))

# 2. Use map() to add tax (8%) to all prices
prices_with_tax = list(map(lambda x: x * 1.08, prices))
# Alternative: prices_with_tax = [price * 1.08 for price in prices]

# 3. Use filter() to find prices under $20
affordable_prices = list(filter(lambda x: x < 20, prices))
# Alternative: affordable_prices = [price for price in prices if price < 20]

# 4. Use map() to convert all prices to integers (rounded down)
rounded_prices = list(map(int, prices))
# Alternative: rounded_prices = [int(price) for price in prices]
```

### Expected Output
```python
print(numbers)           # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(prices_with_tax)   # [21.59, 27.54, 13.77, 9.71, 48.60, 16.47]
print(affordable_prices) # [19.99, 12.75, 8.99, 15.25]
print(rounded_prices)    # [19, 25, 12, 8, 45, 15]
```

### Teaching Notes
- **Key Concept**: Higher-order functions vs comprehensions
- **Common Mistakes**: Forgetting to convert map/filter objects to lists
- **Extensions**: Discuss functional programming concepts

---

## Challenge 7: Combining Concepts ðŸ”´

### Complete Solution

```python
# Student data: (name, age, grades_list)
students = [
    ("Alice", 20, [85, 92, 78]),
    ("Bob", 19, [90, 88, 95]),
    ("Carol", 21, [76, 82, 85])
]

# Solutions:
# 1. Create a set of all unique ages
unique_ages = {student[1] for student in students}
# Alternative: unique_ages = set(student[1] for student in students)

# 2. Use list comprehension to get all student names
names = [student[0] for student in students]

# 3. Create a list of average grades for each student
averages = [sum(student[2]) / len(student[2]) for student in students]
# Alternative: averages = [sum(grades)/len(grades) for name, age, grades in students]

# 4. Find students with average grade above 85
high_performers = [student[0] for student in students if sum(student[2])/len(student[2]) > 85]

# 5. Clone the students list and add a new student
students_copy = students.copy()  # Shallow copy is sufficient here
students_copy.append(("David", 22, [88, 91, 87]))
```

### Expected Output
```python
print(unique_ages)      # {19, 20, 21}
print(names)            # ['Alice', 'Bob', 'Carol']
print(averages)         # [85.0, 91.0, 81.0]
print(high_performers)  # ['Bob']
print(len(students_copy)) # 4 (original has 3)
```

### Teaching Notes
- **Key Concept**: Integrating multiple data structure concepts
- **Common Mistakes**: Complex nested indexing errors
- **Extensions**: Ask students to add more complex operations

---

## Assessment Rubric ðŸ“Š

### Grading Guidelines (Total: 100 points)

| Challenge | Points | Key Assessment Criteria |
|-----------|--------|------------------------|
| Challenge 1 | 10 | Tuple creation, indexing, basic operations |
| Challenge 2 | 15 | List comprehension syntax and conditions |
| Challenge 3 | 10 | Set operations and understanding |
| Challenge 4 | 15 | 2D list manipulation and comprehensions |
| Challenge 5 | 15 | Proper list cloning techniques |
| Challenge 6 | 15 | Higher-order functions usage |
| Challenge 7 | 20 | Integration of multiple concepts |

### Common Student Difficulties

1. **Tuple Immutability**: Students try to modify tuples
2. **List Comprehension Syntax**: Forgetting conditions or brackets
3. **Set vs List**: Confusion about when to use each
4. **2D Indexing**: Row/column confusion
5. **Shallow vs Deep Copy**: Not understanding reference vs copy
6. **Map/Filter**: Forgetting to convert to list for Python 3

### Extension Activities

- **Performance Comparison**: Time list comprehensions vs loops
- **Memory Usage**: Compare sets vs lists for large datasets
- **Real-world Applications**: Student gradebook, inventory system
- **Error Handling**: Add try/except blocks to solutions
- **Advanced Comprehensions**: Nested comprehensions and dictionary comprehensions

---

## Quick Reference for Teaching ðŸ“š

### Key Talking Points

1. **Tuples**: "Sealed containers" - great for coordinates, RGB values
2. **Lists**: "Dynamic arrays" - use when data changes
3. **Sets**: "Unique collections" - fast membership testing
4. **Comprehensions**: "Pythonic loops" - more readable and often faster
5. **Cloning**: "Independent copies" - prevents unwanted side effects

### Live Demo Suggestions

1. Show tuple unpacking: `name, grade, major = student1`
2. Demonstrate set speed: `"item" in large_set` vs `"item" in large_list`
3. Show aliasing problem: `list2 = list1; list2.append(x)`
4. Compare comprehension vs loop performance with `timeit`

### Student Misconceptions to Address

- "Lists and tuples are the same thing"
- "Sets maintain order" (in older Python versions)
- "List comprehensions are always better than loops"
- "Copying with = creates independent lists"

### Time Management Tips

- **5-minute challenges**: Focus on single concepts
- **10-minute challenges**: Combine 2-3 related concepts
- **15-minute challenges**: Integration exercises
- **Quick checks**: Use interactive Python shell for immediate feedback

### Debugging Common Errors

1. **IndexError**: Always check bounds in 2D lists
2. **TypeError**: Remember tuples are immutable
3. **UnboundLocalError**: Watch variable scoping in comprehensions
4. **AttributeError**: Check that sets vs lists have different methods

---

## Answer Key Summary ðŸ”‘

### Quick Reference Solutions

```python
# Challenge 1: Tuple Practice
all_students = (student1, student2, student3)
alice_grade = student1[1]  # 85
names = [s[0] for s in all_students]
high_grades = sum(1 for s in all_students if s[1] > 80)

# Challenge 2: List Comprehensions
even_squares = [x**2 for x in numbers if x % 2 == 0]
long_words_upper = [w.upper() for w in words if len(w) > 5]
divisible_by_3 = [x for x in range(1, 21) if x % 3 == 0]
first_letters = [word[0] for word in words]

# Challenge 3: Set Operations
both_classes = class_a & class_b
only_class_a = class_a - class_b
unique_grades = set(grades)
total_students = len(class_a | class_b)

# Challenge 4: 2D Lists
board[1][1] = 'X'  # center
board[0][0] = 'O'  # top-left
empty_positions = [(i,j) for i in range(3) for j in range(3) if board[i][j] == ' ']
center_has_x = 'X' in board[1]

# Challenge 5: List Cloning
shopping_copy = original_list.copy()
shopping_copy.append("grapes")
fruit_copy = original_list.copy()
fruit_copy.remove("bananas")

# Challenge 6: Range and Map
numbers = list(range(10))
prices_with_tax = list(map(lambda x: x * 1.08, prices))
affordable_prices = list(filter(lambda x: x < 20, prices))
rounded_prices = list(map(int, prices))

# Challenge 7: Integration
unique_ages = {student[1] for student in students}
names = [student[0] for student in students]
averages = [sum(student[2])/len(student[2]) for student in students]
high_performers = [s[0] for s in students if sum(s[2])/len(s[2]) > 85]
students_copy = students.copy()
students_copy.append(("David", 22, [88, 91, 87]))
```

::: {style="color: #27AE60; text-align: center; font-size: 1.2em;"}
This instructor guide provides manageable, focused challenges that students can complete successfully in class! ðŸŽ¯âœ¨
:::